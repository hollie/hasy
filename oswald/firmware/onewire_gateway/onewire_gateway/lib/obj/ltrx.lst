

HI-TECH Software Macro Assembler (PSoC MCU) V9.61PL1
                                                                                                           Fri Feb 06 16:23:18 2009


     1                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2                          ;;;
     3                          ;;;  M8C.INC -- M8C29000 Microcontroller Family System Declarations
     4                          ;;;
     5                          ;;;  Copyright (c) 2004 Cypress MicroSystems, Inc. All rights reserved.
     6                          ;;;
     7                          ;;;
     8                          ;;;  This file provides address constants, bit field masks and a set of macro
     9                          ;;;  facilities for the Cypress MicroSystems 29xxx Microcontroller family.
    10                          ;;;
    11                          ;;;  Last Modified: August 2, 2004
    12                          ;;;
    13                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    14                          
    15                          ;;=============================================================================
    16                          ;; Definition of abbreviations used in the descriptions below
    17                          ;;  (RW)   The register or bit supports reads and writes
    18                          ;;  (W)    The register or bit is write-only
    19                          ;;  (R)    The register or bit is read-only
    20                          ;;  (#)    Access to the register is bit specific (see the family datasheet)
    21                          ;;  (RC)   The register or bit can be read, but writing a 0 will clear it,
    22                          ;;         writing a 1 will have no effect.
    23                          ;;=============================================================================
    24                          
    25                          ;;=============================================================================
    26                          ;;      System Registers
    27                          ;;=============================================================================
    28                          
    29                          ;----------------------------
    30                          ;  Flag Register Bit Fields
    31                          ;----------------------------
    32  00C0                    FLAG_PGMODE_MASK:  equ 0C0h     ; Paging control for > 256 bytes of RAM
    33  0000                    FLAG_PGMODE_0:     equ 00h       ; Direct to Page 0,      indexed to Page 0
    34  0040                    FLAG_PGMODE_1:     equ 40h       ; Direct to Page 0,      indexed to STK_PP page
    35  0080                    FLAG_PGMODE_2:     equ 80h       ; Direct to CUR_PP page, indexed to IDX_PP page
    36  00C0                    FLAG_PGMODE_3:     equ 0C0h       ; Direct to CUR_PP page, indexed to STK_PP page
    37  0000                    FLAG_PGMODE_00b:   equ 00h       ; Same as PGMODE_0
    38  0040                    FLAG_PGMODE_01b:   equ 40h       ; Same as PGMODE_1
    39  0080                    FLAG_PGMODE_10b:   equ 80h       ; Same as PGMODE_2
    40  00C0                    FLAG_PGMODE_11b:   equ 0C0h       ; Same as PGMODE_3
    41  0010                    FLAG_XIO_MASK:     equ 10h     ; I/O Bank select for register space
    42  0008                    FLAG_SUPER:        equ 08h     ; Supervisor Mode
    43  0004                    FLAG_CARRY:        equ 04h     ; Carry Condition Flag
    44  0002                    FLAG_ZERO:         equ 02h     ; Zero  Condition Flag
    45  0001                    FLAG_GLOBAL_IE:    equ 01h     ; Glogal Interrupt Enable
    46                          
    47                          
    48                          ;;=============================================================================
    49                          ;;      Register Space, Bank 0
    50                          ;;=============================================================================
    51                          
    52                          ;------------------------------------------------
    53                          ;  Port Registers
    54                          ;  Note: Also see this address range in Bank 1.
    55                          ;------------------------------------------------
    56                          ; Port 0
    57  0000                    PRT0DR:       equ 00h          ; Port 0 Data Register                     (RW)
    58  0001                    PRT0IE:       equ 01h          ; Port 0 Interrupt Enable Register         (RW)
    59  0002                    PRT0GS:       equ 02h          ; Port 0 Global Select Register            (RW)
    60  0003                    PRT0DM2:      equ 03h          ; Port 0 Drive Mode 2                      (RW)
    61                          ; Port 1
    62  0004                    PRT1DR:       equ 04h          ; Port 1 Data Register                     (RW)
    63  0005                    PRT1IE:       equ 05h          ; Port 1 Interrupt Enable Register         (RW)
    64  0006                    PRT1GS:       equ 06h          ; Port 1 Global Select Register            (RW)
    65  0007                    PRT1DM2:      equ 07h          ; Port 1 Drive Mode 2                      (RW)
    66                          ; Port 2
    67  0008                    PRT2DR:       equ 08h          ; Port 2 Data Register                     (RW)
    68  0009                    PRT2IE:       equ 09h          ; Port 2 Interrupt Enable Register         (RW)
    69  000A                    PRT2GS:       equ 0Ah          ; Port 2 Global Select Register            (RW)
    70  000B                    PRT2DM2:      equ 0Bh          ; Port 2 Drive Mode 2                      (RW)
    71                          ; Port 3
    72  000C                    PRT3DR:       equ 0Ch          ; Port 3 Data Register                     (RW)
    73  000D                    PRT3IE:       equ 0Dh          ; Port 3 Interrupt Enable Register         (RW)
    74  000E                    PRT3GS:       equ 0Eh          ; Port 3 Global Select Register            (RW)
    75  000F                    PRT3DM2:      equ 0Fh          ; Port 3 Drive Mode 2                      (RW)
    76                          ; Port 4
    77  0010                    PRT4DR:       equ 10h          ; Port 4 Data Register                     (RW)
    78  0011                    PRT4IE:       equ 11h          ; Port 4 Interrupt Enable Register         (RW)
    79  0012                    PRT4GS:       equ 12h          ; Port 4 Global Select Register            (RW)
    80  0013                    PRT4DM2:      equ 13h          ; Port 4 Drive Mode 2                      (RW)
    81                          ; Port 5
    82  0014                    PRT5DR:       equ 14h          ; Port 5 Data Register                     (RW)
    83  0015                    PRT5IE:       equ 15h          ; Port 5 Interrupt Enable Register         (RW)
    84  0016                    PRT5GS:       equ 16h          ; Port 5 Global Select Register            (RW)
    85  0017                    PRT5DM2:      equ 17h          ; Port 5 Drive Mode 2                      (RW)
    86                          ; Port 6
    87  0018                    PRT6DR:       equ 18h          ; Port 6 Data Register                     (RW)
    88  0019                    PRT6IE:       equ 19h          ; Port 6 Interrupt Enable Register         (RW)
    89  001A                    PRT6GS:       equ 1Ah          ; Port 6 Global Select Register            (RW)
    90  001B                    PRT6DM2:      equ 1Bh          ; Port 6 Drive Mode 2                      (RW)
    91                          ; Port 7
    92  001C                    PRT7DR:       equ 1Ch          ; Port 7 Data Register                     (RW)
    93  001D                    PRT7IE:       equ 1Dh          ; Port 7 Interrupt Enable Register         (RW)
    94  001E                    PRT7GS:       equ 1Eh          ; Port 7 Global Select Register            (RW)
    95  001F                    PRT7DM2:      equ 1Fh          ; Port 7 Drive Mode 2                      (RW)
    96                          
    97                          ;------------------------------------------------
    98                          ;  Digital PSoC(tm) block Registers
    99                          ;  Note: Also see this address range in Bank 1.
   100                          ;------------------------------------------------
   101                          ; Digital PSoC block 00, Basic Type B
   102  0020                    DBB00DR0:     equ 20h          ; data register 0                          (#)
   103  0021                    DBB00DR1:     equ 21h          ; data register 1                          (W)
   104  0022                    DBB00DR2:     equ 22h          ; data register 2                          (RW)
   105  0023                    DBB00CR0:     equ 23h          ; control & status register 0              (#)
   106                          
   107                          ; Digital PSoC block 01, Basic Type B
   108  0024                    DBB01DR0:     equ 24h          ; data register 0                          (#)
   109  0025                    DBB01DR1:     equ 25h          ; data register 1                          (W)
   110  0026                    DBB01DR2:     equ 26h          ; data register 2                          (RW)
   111  0027                    DBB01CR0:     equ 27h          ; control & status register 0              (#)
   112                          
   113                          ; Digital PSoC block 02, Communications Type B
   114  0028                    DCB02DR0:     equ 28h          ; data register 0                          (#)
   115  0029                    DCB02DR1:     equ 29h          ; data register 1                          (W)
   116  002A                    DCB02DR2:     equ 2Ah          ; data register 2                          (RW)
   117  002B                    DCB02CR0:     equ 2Bh          ; control & status register 0              (#)
   118                          
   119                          ; Digital PSoC block 03, Communications Type B
   120  002C                    DCB03DR0:     equ 2Ch          ; data register 0                          (#)
   121  002D                    DCB03DR1:     equ 2Dh          ; data register 1                          (W)
   122  002E                    DCB03DR2:     equ 2Eh          ; data register 2                          (RW)
   123  002F                    DCB03CR0:     equ 2Fh          ; control & status register 0              (#)
   124                          
   125                          ; Digital PSoC block 10, Basic Type B
   126  0030                    DBB10DR0:     equ 30h          ; data register 0                          (#)
   127  0031                    DBB10DR1:     equ 31h          ; data register 1                          (W)
   128  0032                    DBB10DR2:     equ 32h          ; data register 2                          (RW)
   129  0033                    DBB10CR0:     equ 33h          ; control & status register 0              (#)
   130                          
   131                          ; Digital PSoC block 11, Basic Type B
   132  0034                    DBB11DR0:     equ 34h          ; data register 0                          (#)
   133  0035                    DBB11DR1:     equ 35h          ; data register 1                          (W)
   134  0036                    DBB11DR2:     equ 36h          ; data register 2                          (RW)
   135  0037                    DBB11CR0:     equ 37h          ; control & status register 0              (#)
   136                          
   137                          ; Digital PSoC block 12, Communications Type B
   138  0038                    DCB12DR0:     equ 38h          ; data register 0                          (#)
   139  0039                    DCB12DR1:     equ 39h          ; data register 1                          (W)
   140  003A                    DCB12DR2:     equ 3Ah          ; data register 2                          (RW)
   141  003B                    DCB12CR0:     equ 3Bh          ; control & status register 0              (#)
   142                          
   143                          ; Digital PSoC block 13, Communications Type B
   144  003C                    DCB13DR0:     equ 3Ch          ; data register 0                          (#)
   145  003D                    DCB13DR1:     equ 3Dh          ; data register 1                          (W)
   146  003E                    DCB13DR2:     equ 3Eh          ; data register 2                          (RW)
   147  003F                    DCB13CR0:     equ 3Fh          ; control & status register 0              (#)
   148                          
   149                          ; Digital PSoC block 20, Basic Type B
   150  0040                    DBB20DR0:     equ 40h          ; data register 0                          (#)
   151  0041                    DBB20DR1:     equ 41h          ; data register 1                          (W)
   152  0042                    DBB20DR2:     equ 42h          ; data register 2                          (RW)
   153  0043                    DBB20CR0:     equ 43h          ; control & status register 0              (#)
   154                          
   155                          ; Digital PSoC block 21, Basic Type B
   156  0044                    DBB21DR0:     equ 44h          ; data register 0                          (#)
   157  0045                    DBB21DR1:     equ 45h          ; data register 1                          (W)
   158  0046                    DBB21DR2:     equ 46h          ; data register 2                          (RW)
   159  0047                    DBB21CR0:     equ 47h          ; control & status register 0              (#)
   160                          
   161                          ; Digital PSoC block 22, Communications Type B
   162  0048                    DCB22DR0:     equ 48h          ; data register 0                          (#)
   163  0049                    DCB22DR1:     equ 49h          ; data register 1                          (W)
   164  004A                    DCB22DR2:     equ 4Ah          ; data register 2                          (RW)
   165  004B                    DCB22CR0:     equ 4Bh          ; control & status register 0              (#)
   166                          
   167                          ; Digital PSoC block 23, Communications Type B
   168  004C                    DCB23DR0:     equ 4Ch          ; data register 0                          (#)
   169  004D                    DCB23DR1:     equ 4Dh          ; data register 1                          (W)
   170  004E                    DCB23DR2:     equ 4Eh          ; data register 2                          (RW)
   171  004F                    DCB23CR0:     equ 4Fh          ; control & status register 0              (#)
   172                          
   173                          ; Digital PSoC block 30, Basic Type B
   174  0050                    DBB30DR0:     equ 50h          ; data register 0                          (#)
   175  0051                    DBB30DR1:     equ 51h          ; data register 1                          (W)
   176  0052                    DBB30DR2:     equ 52h          ; data register 2                          (RW)
   177  0053                    DBB30CR0:     equ 53h          ; control & status register 0              (#)
   178                          
   179                          ; Digital PSoC block 31, Basic Type B
   180  0054                    DBB31DR0:     equ 54h          ; data register 0                          (#)
   181  0055                    DBB31DR1:     equ 55h          ; data register 1                          (W)
   182  0056                    DBB31DR2:     equ 56h          ; data register 2                          (RW)
   183  0057                    DBB31CR0:     equ 57h          ; control & status register 0              (#)
   184                          
   185                          ; Digital PSoC block 32, Communications Type B
   186  0058                    DCB32DR0:     equ 58h          ; data register 0                          (#)
   187  0059                    DCB32DR1:     equ 59h          ; data register 1                          (W)
   188  005A                    DCB32DR2:     equ 5Ah          ; data register 2                          (RW)
   189  005B                    DCB32CR0:     equ 5Bh          ; control & status register 0              (#)
   190                          
   191                          ; Digital PSoC block 33, Communications Type B
   192  005C                    DCB33DR0:     equ 5Ch          ; data register 0                          (#)
   193  005D                    DCB33DR1:     equ 5Dh          ; data register 1                          (W)
   194  005E                    DCB33DR2:     equ 5Eh          ; data register 2                          (RW)
   195  005F                    DCB33CR0:     equ 5Fh          ; control & status register 0              (#)
   196                          
   197                          ;-------------------------------------
   198                          ;  Analog Resource Control Registers
   199                          ;-------------------------------------
   200  0060                    AMX_IN:       equ 60h          ; Analog Input Multiplexor Control         (RW)
   201  00C0                    AMX_IN_ACI3:          equ 0C0h    ; MASK: column 3 input mux
   202  0030                    AMX_IN_ACI2:          equ 30h    ; MASK: column 2 input mux
   203  000C                    AMX_IN_ACI1:          equ 0Ch    ; MASK: column 1 input mux
   204  0003                    AMX_IN_ACI0:          equ 03h    ; MASK: column 0 input mux
   205                          
   206  0063                    ARF_CR:       equ 63h          ; Analog Reference Control Register        (RW)
   207  0040                    ARF_CR_HBE:           equ 40h    ; MASK: Bias level control
   208  0038                    ARF_CR_REF:           equ 38h    ; MASK: Analog Reference controls
   209  0007                    ARF_CR_REFPWR:        equ 07h    ; MASK: Analog Reference power
   210  0004                    ARF_CR_APWR:          equ 04h    ; MASK: use deprecated; see datasheet
   211  0003                    ARF_CR_SCPWR:         equ 03h    ; MASK: Switched Cap block power
   212                          
   213  0064                    CMP_CR0:      equ 64h          ; Analog Comparator Bus 0 Register         (#)
   214  0080                    CMP_CR0_COMP3:        equ 80h    ; MASK: Column 3 comparator state        (R)
   215  0040                    CMP_CR0_COMP2:        equ 40h    ; MASK: Column 2 comparator state        (R)
   216  0020                    CMP_CR0_COMP1:        equ 20h    ; MASK: Column 1 comparator state        (R)
   217  0010                    CMP_CR0_COMP0:        equ 10h    ; MASK: Column 0 comparator state        (R)
   218  0008                    CMP_CR0_AINT3:        equ 08h    ; MASK: Column 3 interrupt source        (RW)
   219  0004                    CMP_CR0_AINT2:        equ 04h    ; MASK: Column 2 interrupt source        (RW)
   220  0002                    CMP_CR0_AINT1:        equ 02h    ; MASK: Column 1 interrupt source        (RW)
   221  0001                    CMP_CR0_AINT0:        equ 01h    ; MASK: Column 0 interrupt source        (RW)
   222                          
   223  0065                    ASY_CR:       equ 65h          ; Analog Synchronizaton Control            (#)
   224  0070                    ASY_CR_SARCOUNT:      equ 70h    ; MASK: SAR support: resolution count    (W)
   225  0008                    ASY_CR_SARSIGN:       equ 08h    ; MASK: SAR support: sign                (RW)
   226  0006                    ASY_CR_SARCOL:        equ 06h    ; MASK: SAR support: column spec         (RW)
   227  0001                    ASY_CR_SYNCEN:        equ 01h    ; MASK: Stall bit                        (RW)
   228                          
   229  0066                    CMP_CR1:      equ 66h          ; Analog Comparator Bus 1 Register         (RW)
   230  0080                    CMP_CR1_ASYNCH3:      equ 80h    ; MASK: Column 3 comparator bus synch
   231  0040                    CMP_CR1_ASYNCH2:      equ 40h    ; MASK: Column 2 comparator bus synch
   232  0020                    CMP_CR1_ASYNCH1:      equ 20h    ; MASK: Column 1 comparator bus synch
   233  0010                    CMP_CR1_ASYNCH0:      equ 10h    ; MASK: Column 0 comparator bus synch
   234                          
   235                          ;---------------------------------------------------
   236                          ;  Analog PSoC block Registers
   237                          ;
   238                          ;  Note: the following registers are mapped into
   239                          ;  both register bank 0 AND register bank 1.
   240                          ;---------------------------------------------------
   241                          
   242                          ; Continuous Time PSoC block Type B Row 0 Col 0
   243  0070                    ACB00CR3:     equ 70h          ; Control register 3                       (RW)
   244  0071                    ACB00CR0:     equ 71h          ; Control register 0                       (RW)
   245  0072                    ACB00CR1:     equ 72h          ; Control register 1                       (RW)
   246  0073                    ACB00CR2:     equ 73h          ; Control register 2                       (RW)
   247                          
   248                          ; Continuous Time PSoC block Type B Row 0 Col 1
   249  0074                    ACB01CR3:     equ 74h          ; Control register 3                       (RW)
   250  0075                    ACB01CR0:     equ 75h          ; Control register 0                       (RW)
   251  0076                    ACB01CR1:     equ 76h          ; Control register 1                       (RW)
   252  0077                    ACB01CR2:     equ 77h          ; Control register 2                       (RW)
   253                          
   254                          ; Continuous Time PSoC block Type B Row 0 Col 2
   255  0078                    ACB02CR3:     equ 78h          ; Control register 3                       (RW)
   256  0079                    ACB02CR0:     equ 79h          ; Control register 0                       (RW)
   257  007A                    ACB02CR1:     equ 7Ah          ; Control register 1                       (RW)
   258  007B                    ACB02CR2:     equ 7Bh          ; Control register 2                       (RW)
   259                          
   260                          ; Continuous Time PSoC block Type B Row 0 Col 3
   261  007C                    ACB03CR3:     equ 7Ch          ; Control register 3                       (RW)
   262  007D                    ACB03CR0:     equ 7Dh          ; Control register 0                       (RW)
   263  007E                    ACB03CR1:     equ 7Eh          ; Control register 1                       (RW)
   264  007F                    ACB03CR2:     equ 7Fh          ; Control register 2                       (RW)
   265                          
   266                          ; Switched Cap PSoC blockType C Row 1 Col 0
   267  0080                    ASC10CR0:     equ 80h          ; Control register 0                       (RW)
   268  0081                    ASC10CR1:     equ 81h          ; Control register 1                       (RW)
   269  0082                    ASC10CR2:     equ 82h          ; Control register 2                       (RW)
   270  0083                    ASC10CR3:     equ 83h          ; Control register 3                       (RW)
   271                          
   272                          ; Switched Cap PSoC blockType D Row 1 Col 1
   273  0084                    ASD11CR0:     equ 84h          ; Control register 0                       (RW)
   274  0085                    ASD11CR1:     equ 85h          ; Control register 1                       (RW)
   275  0086                    ASD11CR2:     equ 86h          ; Control register 2                       (RW)
   276  0087                    ASD11CR3:     equ 87h          ; Control register 3                       (RW)
   277                          
   278                          ; Switched Cap PSoC blockType C Row 1 Col 2
   279  0088                    ASC12CR0:     equ 88h          ; Control register 0                       (RW)
   280  0089                    ASC12CR1:     equ 89h          ; Control register 1                       (RW)
   281  008A                    ASC12CR2:     equ 8Ah          ; Control register 2                       (RW)
   282  008B                    ASC12CR3:     equ 8Bh          ; Control register 3                       (RW)
   283                          
   284                          ; Switched Cap PSoC blockType D Row 1 Col 3
   285  008C                    ASD13CR0:     equ 8Ch          ; Control register 0                       (RW)
   286  008D                    ASD13CR1:     equ 8Dh          ; Control register 1                       (RW)
   287  008E                    ASD13CR2:     equ 8Eh          ; Control register 2                       (RW)
   288  008F                    ASD13CR3:     equ 8Fh          ; Control register 3                       (RW)
   289                          
   290                          ; Switched Cap PSoC blockType D Row 2 Col 0
   291  0090                    ASD20CR0:     equ 90h          ; Control register 0                       (RW)
   292  0091                    ASD20CR1:     equ 91h          ; Control register 1                       (RW)
   293  0092                    ASD20CR2:     equ 92h          ; Control register 2                       (RW)
   294  0093                    ASD20CR3:     equ 93h          ; Control register 3                       (RW)
   295                          
   296                          ; Switched Cap PSoC blockType C Row 2 Col 1
   297  0094                    ASC21CR0:     equ 94h          ; Control register 0                       (RW)
   298  0095                    ASC21CR1:     equ 95h          ; Control register 1                       (RW)
   299  0096                    ASC21CR2:     equ 96h          ; Control register 2                       (RW)
   300  0097                    ASC21CR3:     equ 97h          ; Control register 3                       (RW)
   301                          
   302                          ; Switched Cap PSoC blockType D Row 2 Col 2
   303  0098                    ASD22CR0:     equ 98h          ; Control register 0                       (RW)
   304  0099                    ASD22CR1:     equ 99h          ; Control register 1                       (RW)
   305  009A                    ASD22CR2:     equ 9Ah          ; Control register 2                       (RW)
   306  009B                    ASD22CR3:     equ 9Bh          ; Control register 3                       (RW)
   307                          
   308                          ; Switched Cap PSoC blockType C Row 2 Col 3
   309  009C                    ASC23CR0:     equ 9Ch          ; Control register 0                       (RW)
   310  009D                    ASC23CR1:     equ 9Dh          ; Control register 1                       (RW)
   311  009E                    ASC23CR2:     equ 9Eh          ; Control register 2                       (RW)
   312  009F                    ASC23CR3:     equ 9Fh          ; Control register 3                       (RW)
   313                          
   314                          ;-----------------------------------------------
   315                          ;  Global General Purpose Data Registers
   316                          ;-----------------------------------------------
   317  006C                    TMP0_DR:      equ 6Ch          ; deprecated do not use
   318  006D                    TMP1_DR:      equ 6Dh          ; deprecated do not use
   319  006E                    TMP2_DR:      equ 6Eh          ; deprecated do not use
   320  006F                    TMP3_DR:      equ 6Fh          ; deprecated do not use
   321                          
   322  006C                    TMP_DR0:      equ 6Ch          ; Temporary Data Register 0                (RW)
   323  006D                    TMP_DR1:      equ 6Dh          ; Temporary Data Register 1                (RW)
   324  006E                    TMP_DR2:      equ 6Eh          ; Temporary Data Register 2                (RW)
   325  006F                    TMP_DR3:      equ 6Fh          ; Temporary Data Register 3                (RW)
   326                          
   327                          ;------------------------------------------------
   328                          ;  Row Digital Interconnects
   329                          ;
   330                          ;  Note: the following registers are mapped into
   331                          ;  both register bank 0 AND register bank 1.
   332                          ;------------------------------------------------
   333                          
   334  00B0                    RDI0RI:       equ 0B0h          ; Row Digital Interconnect Row 0 Input Reg (RW)
   335  00B1                    RDI0SYN:      equ 0B1h          ; Row Digital Interconnect Row 0 Sync Reg  (RW)
   336  00B2                    RDI0IS:       equ 0B2h          ; Row 0 Input Select Register              (RW)
   337  00B3                    RDI0LT0:      equ 0B3h          ; Row 0 Look Up Table Register 0           (RW)
   338  00B4                    RDI0LT1:      equ 0B4h          ; Row 0 Look Up Table Register 1           (RW)
   339  00B5                    RDI0RO0:      equ 0B5h          ; Row 0 Output Register 0                  (RW)
   340  00B6                    RDI0RO1:      equ 0B6h          ; Row 0 Output Register 1                  (RW)
   341                          
   342  00B8                    RDI1RI:       equ 0B8h          ; Row Digital Interconnect Row 1 Input Reg (RW)
   343  00B9                    RDI1SYN:      equ 0B9h          ; Row Digital Interconnect Row 1 Sync Reg  (RW)
   344  00BA                    RDI1IS:       equ 0BAh          ; Row 1 Input Select Register              (RW)
   345  00BB                    RDI1LT0:      equ 0BBh          ; Row 1 Look Up Table Register 0           (RW)
   346  00BC                    RDI1LT1:      equ 0BCh          ; Row 1 Look Up Table Register 1           (RW)
   347  00BD                    RDI1RO0:      equ 0BDh          ; Row 1 Output Register 0                  (RW)
   348  00BE                    RDI1RO1:      equ 0BEh          ; Row 1 Output Register 1                  (RW)
   349                          
   350  00C0                    RDI2RI:       equ 0C0h          ; Row Digital Interconnect Row 2 Input Reg (RW)
   351  00C1                    RDI2SYN:      equ 0C1h          ; Row Digital Interconnect Row 2 Sync Reg  (RW)
   352  00C2                    RDI2IS:       equ 0C2h          ; Row 2 Input Select Register              (RW)
   353  00C3                    RDI2LT0:      equ 0C3h          ; Row 2 Look Up Table Register 0           (RW)
   354  00C4                    RDI2LT1:      equ 0C4h          ; Row 2 Look Up Table Register 1           (RW)
   355  00C5                    RDI2RO0:      equ 0C5h          ; Row 2 Output Register 0                  (RW)
   356  00C6                    RDI2RO1:      equ 0C6h          ; Row 2 Output Register 1                  (RW)
   357                          
   358  00C8                    RDI3RI:       equ 0C8h          ; Row Digital Interconnect Row 3 Input Reg (RW)
   359  00C9                    RDI3SYN:      equ 0C9h          ; Row Digital Interconnect Row 3 Sync Reg  (RW)
   360  00CA                    RDI3IS:       equ 0CAh          ; Row 3 Input Select Register              (RW)
   361  00CB                    RDI3LT0:      equ 0CBh          ; Row 3 Look Up Table Register 0           (RW)
   362  00CC                    RDI3LT1:      equ 0CCh          ; Row 3 Look Up Table Register 1           (RW)
   363  00CD                    RDI3RO0:      equ 0CDh          ; Row 3 Output Register 0                  (RW)
   364  00CE                    RDI3RO1:      equ 0CEh          ; Row 3 Output Register 1                  (RW)
   365                          
   366                          ;-----------------------------------------------
   367                          ;  Ram Page Pointers
   368                          ;-----------------------------------------------
   369  00D0                    CUR_PP:      equ 0D0h           ; Current   Page Pointer
   370  00D1                    STK_PP:      equ 0D1h           ; Stack     Page Pointer
   371  00D3                    IDX_PP:      equ 0D3h           ; Index     Page Pointer
   372  00D4                    MVR_PP:      equ 0D4h           ; MVI Read  Page Pointer
   373  00D5                    MVW_PP:      equ 0D5h           ; MVI Write Page Pointer
   374                          
   375                          ;------------------------------------------------
   376                          ;  I2C Configuration Registers
   377                          ;------------------------------------------------
   378  00D6                    I2C_CFG:      equ 0D6h          ; I2C Configuration Register               (RW)
   379  0040                    I2C_CFG_PINSEL:         equ 40h  ; MASK: Select P1[0] and P1[1] for I2C
   380  0020                    I2C_CFG_BUSERR_IE:      equ 20h  ; MASK: Enable interrupt on Bus Error
   381  0010                    I2C_CFG_STOP_IE:        equ 10h  ; MASK: Enable interrupt on Stop
   382  0000                    I2C_CFG_CLK_RATE_100K:  equ 00h  ; MASK: I2C clock set at 100K
   383  0004                    I2C_CFG_CLK_RATE_400K:  equ 04h  ; MASK: I2C clock set at 400K
   384  0008                    I2C_CFG_CLK_RATE_50K:   equ 08h  ; MASK: I2C clock set at 50K
   385  000C                    I2C_CFG_CLK_RATE_1M6:   equ 0Ch  ; MASK: I2C clock set at 1.6M
   386  000C                    I2C_CFG_CLK_RATE:       equ 0Ch  ; MASK: I2C clock rate setting mask
   387  0002                    I2C_CFG_PSELECT_MASTER: equ 02h  ; MASK: Enable I2C Master
   388  0001                    I2C_CFG_PSELECT_SLAVE:  equ 01h  ; MASK: Enable I2C Slave
   389                          
   390  00D7                    I2C_SCR:      equ 0D7h          ; I2C Status and Control Register          (#)
   391  0080                    I2C_SCR_BUSERR:        equ 80h   ; MASK: I2C Bus Error detected           (RC)
   392  0040                    I2C_SCR_LOSTARB:       equ 40h   ; MASK: I2C Arbitration lost             (RC)
   393  0020                    I2C_SCR_STOP:          equ 20h   ; MASK: I2C Stop detected                (RC)
   394  0010                    I2C_SCR_ACK:           equ 10h   ; MASK: ACK the last byte                (RW)
   395  0008                    I2C_SCR_ADDR:          equ 08h   ; MASK: Address rcv'd is Slave address   (RC)
   396  0004                    I2C_SCR_XMIT:          equ 04h   ; MASK: Set transfer to tranmit mode     (RW)
   397  0002                    I2C_SCR_LRB:           equ 02h   ; MASK: Last recieved bit                (RC)
   398  0001                    I2C_SCR_BYTECOMPLETE:  equ 01h   ; MASK: Transfer of byte complete        (RC)
   399                          
   400  00D8                    I2C_DR:       equ 0D8h          ; I2C Data Register                        (RW)
   401                          
   402  00D9                    I2C_MSCR:     equ 0D9h          ; I2C Master Status and Control Register   (#)
   403  0008                    I2C_MSCR_BUSY:         equ 08h   ; MASK: I2C Busy (Start detected)        (R)
   404  0004                    I2C_MSCR_MODE:         equ 04h   ; MASK: Start has been generated         (R)
   405  0002                    I2C_MSCR_RESTART:      equ 02h   ; MASK: Generate a Restart condition     (RW)
   406  0001                    I2C_MSCR_START:        equ 01h   ; MASK: Generate a Start condition       (RW)
   407                          
   408                          ;------------------------------------------------
   409                          ;  System and Global Resource Registers
   410                          ;------------------------------------------------
   411  00DA                    INT_CLR0:     equ 0DAh          ; Interrupt Clear Register 0               (RW)
   412                                                         ; Use INT_MSK0 bit field masks
   413  00DB                    INT_CLR1:     equ 0DBh          ; Interrupt Clear Register 1               (RW)
   414                                                         ; Use INT_MSK1 bit field masks
   415  00DC                    INT_CLR2:     equ 0DCh          ; Interrupt Clear Register 2               (RW)
   416                                                         ; Use INT_MSK2 bit field masks
   417  00DD                    INT_CLR3:     equ 0DDh          ; Interrupt Clear Register 3               (RW)
   418                                                         ; Use INT_MSK3 bit field masks
   419                          
   420  00DE                    INT_MSK3:     equ 0DEh          ; I2C and Software Mask Register           (RW)
   421  0080                    INT_MSK3_ENSWINT:          equ 80h ; MASK: enable/disable SW interrupt
   422  0001                    INT_MSK3_I2C:              equ 01h ; MASK: enable/disable I2C interrupt
   423                          
   424  00DF                    INT_MSK2:     equ 0DFh          ; Digital PSoC block Mask Register         (RW)
   425  0080                    INT_MSK2_DCB33:            equ 80h ; MASK: enable/disable DCB33 block interrupt
   426  0040                    INT_MSK2_DCB32:            equ 40h ; MASK: enable/disable DCB32 block interrupt
   427  0020                    INT_MSK2_DBB31:            equ 20h ; MASK: enable/disable DBB31 block interrupt
   428  0010                    INT_MSK2_DBB30:            equ 10h ; MASK: enable/disable DBB30 block interrupt
   429  0008                    INT_MSK2_DCB23:            equ 08h ; MASK: enable/disable DCB23 block interrupt
   430  0004                    INT_MSK2_DCB22:            equ 04h ; MASK: enable/disable DCB22 block interrupt
   431  0002                    INT_MSK2_DBB21:            equ 02h ; MASK: enable/disable DBB21 block interrupt
   432  0001                    INT_MSK2_DBB20:            equ 01h ; MASK: enable/disable DBB20 block interrupt
   433                          
   434  00E0                    INT_MSK0:     equ 0E0h          ; General Interrupt Mask Register          (RW)
   435  0080                    INT_MSK0_VC3:              equ 80h ; MASK: enable/disable VC3 interrupt
   436  0040                    INT_MSK0_SLEEP:            equ 40h ; MASK: enable/disable sleep interrupt
   437  0020                    INT_MSK0_GPIO:             equ 20h ; MASK: enable/disable GPIO  interrupt
   438  0010                    INT_MSK0_ACOLUMN_3:        equ 10h ; MASK: enable/disable Analog col 3 interrupt
   439  0008                    INT_MSK0_ACOLUMN_2:        equ 08h ; MASK: enable/disable Analog col 2 interrupt
   440  0004                    INT_MSK0_ACOLUMN_1:        equ 04h ; MASK: enable/disable Analog col 1 interrupt
   441  0002                    INT_MSK0_ACOLUMN_0:        equ 02h ; MASK: enable/disable Analog col 0 interrupt
   442  0001                    INT_MSK0_VOLTAGE_MONITOR:  equ 01h ; MASK: enable/disable Volts interrupt
   443                          
   444  00E1                    INT_MSK1:     equ 0E1h          ; Digital PSoC block Mask Register         (RW)
   445  0080                    INT_MSK1_DCB13:            equ 80h ; MASK: enable/disable DCB13 block interrupt
   446  0040                    INT_MSK1_DCB12:            equ 40h ; MASK: enable/disable DCB12 block interrupt
   447  0020                    INT_MSK1_DBB11:            equ 20h ; MASK: enable/disable DBB11 block interrupt
   448  0010                    INT_MSK1_DBB10:            equ 10h ; MASK: enable/disable DBB10 block interrupt
   449  0008                    INT_MSK1_DCB03:            equ 08h ; MASK: enable/disable DCB03 block interrupt
   450  0004                    INT_MSK1_DCB02:            equ 04h ; MASK: enable/disable DCB02 block interrupt
   451  0002                    INT_MSK1_DBB01:            equ 02h ; MASK: enable/disable DBB01 block interrupt
   452  0001                    INT_MSK1_DBB00:            equ 01h ; MASK: enable/disable DBB00 block interrupt
   453                          
   454  00E2                    INT_VC:       equ 0E2h          ; Interrupt vector register                (RC)
   455  00E3                    RES_WDT:      equ 0E3h          ; Watch Dog Timer Register                 (W)
   456                          
   457                          ; DECIMATOR Registers
   458  00E4                    DEC_DH:       equ 0E4h          ; Data Register (high byte)                (RC)
   459  00E5                    DEC_DL:       equ 0E5h          ; Data Register ( low byte)                (RC)
   460  00E6                    DEC_CR0:      equ 0E6h          ; Data Control Register 0                  (RW)
   461  00E7                    DEC_CR1:      equ 0E7h          ; Data Control Register 1                  (RW)
   462                                                         ; Also see DEC_CR2 in bank 1
   463                          
   464                          ; Multiplier and MAC (Multiply/Accumulate) Unit
   465                          //   Compatibility Set: Maps onto MAC0
   466  00E8                    MUL_X:        equ 0E8h          ; Multiplier X Register (write)            (W)
   467  00E9                    MUL_Y:        equ 0E9h          ; Multiplier Y Register (write)            (W)
   468  00EA                    MUL_DH:       equ 0EAh          ; Multiplier Result Data (high byte read)  (R)
   469  00EB                    MUL_DL:       equ 0EBh          ; Multiplier Result Data ( low byte read)  (R)
   470  00EC                    MAC_X:        equ 0ECh          ; write = MAC X register [also see ACC_DR1]
   471  00EC                    ACC_DR1:      equ MAC_X        ; read =  MAC Accumulator, byte 1          (RW)
   472  00ED                    MAC_Y:        equ 0EDh          ; write = MAC Y register [also see ACC_DR0]
   473  00ED                    ACC_DR0:      equ MAC_Y        ; read =  MAC Accumulator, byte 0          (RW)
   474  00EE                    MAC_CL0:      equ 0EEh          ; write = MAC Clear Accum [also see ACC_DR3]
   475  00EE                    ACC_DR3:      equ MAC_CL0      ; read =  MAC Accumulator, byte 3          (RW)
   476  00EF                    MAC_CL1:      equ 0EFh          ; write = MAC Clear Accum [also see ACC_DR2]
   477  00EF                    ACC_DR2:      equ MAC_CL1      ; read =  MAC Accumulator, byte 2          (RW)
   478                          
   479                          // Multiply/Accumulate Unit 0
   480  00E8                    MUL0_X:       equ 0E8h          ; Multiplier 0 X Register (write)          (W)
   481  00E9                    MUL0_Y:       equ 0E9h          ; Multiplier 0 Y Register (write)          (W)
   482  00EA                    MUL0_DH:      equ 0EAh          ; Multiplier 0 Result Data (high byte read)(R)
   483  00EB                    MUL0_DL:      equ 0EBh          ; Multiplier 0 Result Data ( low byte read)(R)
   484  00EC                    MAC0_X:       equ 0ECh          ; write = MAC 0 X register [also see ACC_DR1]
   485  00EC                    ACC0_DR1:     equ MAC0_X       ; read =  MAC 0 Accumulator, byte 1        (RW)
   486  00ED                    MAC0_Y:       equ 0EDh          ; write = MAC 0 Y register [also see ACC_DR0]
   487  00ED                    ACC0_DR0:     equ MAC0_Y       ; read =  MAC 0 Accumulator, byte 0        (RW)
   488  00EE                    MAC0_CL0:     equ 0EEh          ; write = MAC 0 Clear Accum [also see ACC_DR3]
   489  00EE                    ACC0_DR3:     equ MAC0_CL0     ; read =  MAC 0 Accumulator, byte 3        (RW)
   490  00EF                    MAC0_CL1:     equ 0EFh          ; write = MAC 0 Clear Accum [also see ACC_DR2]
   491  00EF                    ACC0_DR2:     equ MAC0_CL1     ; read =  MAC 0 Accumulator, byte 2        (RW)
   492                          
   493                          // Multiply/Accumulate Unit 1
   494  00A8                    MUL1_X:       equ 0A8h          ; Multiplier 1 X Register (write)          (W)
   495  00A9                    MUL1_Y:       equ 0A9h          ; Multiplier 1 Y Register (write)          (W)
   496  00AA                    MUL1_DH:      equ 0AAh          ; Multiplier 1 Result Data (high byte read)(R)
   497  00AB                    MUL1_DL:      equ 0ABh          ; Multiplier 1 Result Data ( low byte read)(R)
   498  00AC                    MAC1_X:       equ 0ACh          ; write = MAC 1 X register [also see ACC_DR1]
   499  00AC                    ACC1_DR1:     equ MAC1_X       ; read =  MAC 1 Accumulator, byte 1        (RW)
   500  00AD                    MAC1_Y:       equ 0ADh          ; write = MAC 1 Y register [also see ACC_DR0]
   501  00AD                    ACC1_DR0:     equ MAC1_Y       ; read =  MAC 1 Accumulator, byte 0        (RW)
   502  00AE                    MAC1_CL0:     equ 0AEh          ; write = MAC 1 Clear Accum [also see ACC_DR3]
   503  00AE                    ACC1_DR3:     equ MAC1_CL0     ; read =  MAC 1 Accumulator, byte 3        (RW)
   504  00AF                    MAC1_CL1:     equ 0AFh          ; write = MAC 1 Clear Accum [also see ACC_DR2]
   505  00AF                    ACC1_DR2:     equ MAC1_CL1     ; read =  MAC 1 Accumulator, byte 2        (RW)
   506                          
   507                          ;------------------------------------------------------
   508                          ;  System Status and Control Registers
   509                          ;
   510                          ;  Note: The following registers are mapped into both
   511                          ;        register bank 0 AND register bank 1.
   512                          ;------------------------------------------------------
   513  00F7                    CPU_F:        equ 0F7h          ; CPU Flag Register Access                 (RO)
   514                                                             ; Use FLAG_ masks defined at top of file
   515                          
   516  00FE                    CPU_SCR1:     equ 0FEh          ; CPU Status and Control Register #1       (#)
   517  0080                    CPU_SCR1_IRESS:         equ 80h    ; MASK: Boot Phase Re-entry bit
   518  0010                    CPU_SCR1_SLIMO:         equ 10h    ; MASK: Slow Main Oscillator Mode
   519  0008                    CPU_SCR1_ECO_ALWD_WR:   equ 08h    ; MASK: flag, ECO allowed has been written
   520  0004                    CPU_SCR1_ECO_ALLOWED:   equ 04h    ; MASK: ECO allowed to be enabled
   521  0001                    CPU_SCR1_IRAMDIS:       equ 01h    ; MASK: Disable RAM initialization on WDR
   522                          
   523  00FF                    CPU_SCR0:     equ 0FFh          ; CPU Status and Control Register #2       (#)
   524  0080                    CPU_SCR0_GIE_MASK:      equ 80h    ; MASK: Global Interrupt Enable shadow
   525  0020                    CPU_SCR0_WDRS_MASK:     equ 20h    ; MASK: Watch Dog Timer Reset
   526  0010                    CPU_SCR0_PORS_MASK:     equ 10h    ; MASK: power-on reset bit PORS
   527  0008                    CPU_SCR0_SLEEP_MASK:    equ 08h    ; MASK: Enable Sleep
   528  0001                    CPU_SCR0_STOP_MASK:     equ 01h    ; MASK: Halt CPU bit
   529                          
   530                          
   531                          ;;=============================================================================
   532                          ;;      Register Space, Bank 1
   533                          ;;=============================================================================
   534                          
   535                          ;------------------------------------------------
   536                          ;  Port Registers
   537                          ;  Note: Also see this address range in Bank 0.
   538                          ;------------------------------------------------
   539                          ; Port 0
   540  0000                    PRT0DM0:      equ 00h          ; Port 0 Drive Mode 0                      (RW)
   541  0001                    PRT0DM1:      equ 01h          ; Port 0 Drive Mode 1                      (RW)
   542  0002                    PRT0IC0:      equ 02h          ; Port 0 Interrupt Control 0               (RW)
   543  0003                    PRT0IC1:      equ 03h          ; Port 0 Interrupt Control 1               (RW)
   544                          
   545                          ; Port 1
   546  0004                    PRT1DM0:      equ 04h          ; Port 1 Drive Mode 0                      (RW)
   547  0005                    PRT1DM1:      equ 05h          ; Port 1 Drive Mode 1                      (RW)
   548  0006                    PRT1IC0:      equ 06h          ; Port 1 Interrupt Control 0               (RW)
   549  0007                    PRT1IC1:      equ 07h          ; Port 1 Interrupt Control 1               (RW)
   550                          
   551                          ; Port 2
   552  0008                    PRT2DM0:      equ 08h          ; Port 2 Drive Mode 0                      (RW)
   553  0009                    PRT2DM1:      equ 09h          ; Port 2 Drive Mode 1                      (RW)
   554  000A                    PRT2IC0:      equ 0Ah          ; Port 2 Interrupt Control 0               (RW)
   555  000B                    PRT2IC1:      equ 0Bh          ; Port 2 Interrupt Control 1               (RW)
   556                          
   557                          ; Port 3
   558  000C                    PRT3DM0:      equ 0Ch          ; Port 3 Drive Mode 0                      (RW)
   559  000D                    PRT3DM1:      equ 0Dh          ; Port 3 Drive Mode 1                      (RW)
   560  000E                    PRT3IC0:      equ 0Eh          ; Port 3 Interrupt Control 0               (RW)
   561  000F                    PRT3IC1:      equ 0Fh          ; Port 3 Interrupt Control 1               (RW)
   562                          
   563                          ; Port 4
   564  0010                    PRT4DM0:      equ 10h          ; Port 4 Drive Mode 0                      (RW)
   565  0011                    PRT4DM1:      equ 11h          ; Port 4 Drive Mode 1                      (RW)
   566  0012                    PRT4IC0:      equ 12h          ; Port 4 Interrupt Control 0               (RW)
   567  0013                    PRT4IC1:      equ 13h          ; Port 4 Interrupt Control 1               (RW)
   568                          
   569                          ; Port 5
   570  0014                    PRT5DM0:      equ 14h          ; Port 5 Drive Mode 0                      (RW)
   571  0015                    PRT5DM1:      equ 15h          ; Port 5 Drive Mode 1                      (RW)
   572  0016                    PRT5IC0:      equ 16h          ; Port 5 Interrupt Control 0               (RW)
   573  0017                    PRT5IC1:      equ 17h          ; Port 5 Interrupt Control 1               (RW)
   574                          
   575                          ; Port 6
   576  0018                    PRT6DM0:      equ 18h          ; Port 6 Drive Mode 0                      (RW)
   577  0019                    PRT6DM1:      equ 19h          ; Port 6 Drive Mode 1                      (RW)
   578  001A                    PRT6IC0:      equ 1Ah          ; Port 6 Interrupt Control 0               (RW)
   579  001B                    PRT6IC1:      equ 1Bh          ; Port 6 Interrupt Control 1               (RW)
   580                          
   581                          ; Port 7
   582  001C                    PRT7DM0:      equ 1Ch          ; Port 7 Drive Mode 0                      (RW)
   583  001D                    PRT7DM1:      equ 1Dh          ; Port 7 Drive Mode 1                      (RW)
   584  001E                    PRT7IC0:      equ 1Eh          ; Port 7 Interrupt Control 0               (RW)
   585  001F                    PRT7IC1:      equ 1Fh          ; Port 7 Interrupt Control 1               (RW)
   586                          
   587                          ;------------------------------------------------
   588                          ;  Digital PSoC(tm) block Registers
   589                          ;  Note: Also see this address range in Bank 0.
   590                          ;------------------------------------------------
   591                          
   592                          ; Digital PSoC block 00, Basic Type B
   593  0020                    DBB00FN:      equ 20h          ; Function Register                        (RW)
   594  0021                    DBB00IN:      equ 21h          ;    Input Register                        (RW)
   595  0022                    DBB00OU:      equ 22h          ;   Output Register                        (RW)
   596                          
   597                          ; Digital PSoC block 01, Basic Type B
   598  0024                    DBB01FN:      equ 24h          ; Function Register                        (RW)
   599  0025                    DBB01IN:      equ 25h          ;    Input Register                        (RW)
   600  0026                    DBB01OU:      equ 26h          ;   Output Register                        (RW)
   601                          
   602                          ; Digital PSoC block 02, Communications Type B
   603  0028                    DCB02FN:      equ 28h          ; Function Register                        (RW)
   604  0029                    DCB02IN:      equ 29h          ;    Input Register                        (RW)
   605  002A                    DCB02OU:      equ 2Ah          ;   Output Register                        (RW)
   606                          
   607                          ; Digital PSoC block 03, Communications Type B
   608  002C                    DCB03FN:      equ 2Ch          ; Function Register                        (RW)
   609  002D                    DCB03IN:      equ 2Dh          ;    Input Register                        (RW)
   610  002E                    DCB03OU:      equ 2Eh          ;   Output Register                        (RW)
   611                          
   612                          ; Digital PSoC block 10, Basic Type B
   613  0030                    DBB10FN:      equ 30h          ; Function Register                        (RW)
   614  0031                    DBB10IN:      equ 31h          ;    Input Register                        (RW)
   615  0032                    DBB10OU:      equ 32h          ;   Output Register                        (RW)
   616                          
   617                          ; Digital PSoC block 11, Basic Type B
   618  0034                    DBB11FN:      equ 34h          ; Function Register                        (RW)
   619  0035                    DBB11IN:      equ 35h          ;    Input Register                        (RW)
   620  0036                    DBB11OU:      equ 36h          ;   Output Register                        (RW)
   621                          
   622                          ; Digital PSoC block 12, Communications Type B
   623  0038                    DCB12FN:      equ 38h          ; Function Register                        (RW)
   624  0039                    DCB12IN:      equ 39h          ;    Input Register                        (RW)
   625  003A                    DCB12OU:      equ 3Ah          ;   Output Register                        (RW)
   626                          
   627                          ; Digital PSoC block 13, Communications Type B
   628  003C                    DCB13FN:      equ 3Ch          ; Function Register                        (RW)
   629  003D                    DCB13IN:      equ 3Dh          ;    Input Register                        (RW)
   630  003E                    DCB13OU:      equ 3Eh          ;   Output Register                        (RW)
   631                          
   632                          ; Digital PSoC block 20, Basic Type B
   633  0040                    DBB20FN:      equ 40h          ; Function Register                        (RW)
   634  0041                    DBB20IN:      equ 41h          ;    Input Register                        (RW)
   635  0042                    DBB20OU:      equ 42h          ;   Output Register                        (RW)
   636                          
   637                          ; Digital PSoC block 21, Basic Type B
   638  0044                    DBB21FN:      equ 44h          ; Function Register                        (RW)
   639  0045                    DBB21IN:      equ 45h          ;    Input Register                        (RW)
   640  0046                    DBB21OU:      equ 46h          ;   Output Register                        (RW)
   641                          
   642                          ; Digital PSoC block 22, Communications Type B
   643  0048                    DCB22FN:      equ 48h          ; Function Register                        (RW)
   644  0049                    DCB22IN:      equ 49h          ;    Input Register                        (RW)
   645  004A                    DCB22OU:      equ 4Ah          ;   Output Register                        (RW)
   646                          
   647                          ; Digital PSoC block 23, Communications Type B
   648  004C                    DCB23FN:      equ 4Ch          ; Function Register                        (RW)
   649  004D                    DCB23IN:      equ 4Dh          ;    Input Register                        (RW)
   650  004E                    DCB23OU:      equ 4Eh          ;   Output Register                        (RW)
   651                          
   652                          ; Digital PSoC block 30, Basic Type B
   653  0050                    DBB30FN:      equ 50h          ; Function Register                        (RW)
   654  0051                    DBB30IN:      equ 51h          ;    Input Register                        (RW)
   655  0052                    DBB30OU:      equ 52h          ;   Output Register                        (RW)
   656                          
   657                          ; Digital PSoC block 31, Basic Type B
   658  0054                    DBB31FN:      equ 54h          ; Function Register                        (RW)
   659  0055                    DBB31IN:      equ 55h          ;    Input Register                        (RW)
   660  0056                    DBB31OU:      equ 56h          ;   Output Register                        (RW)
   661                          
   662                          ; Digital PSoC block 32, Communications Type B
   663  0058                    DCB32FN:      equ 58h          ; Function Register                        (RW)
   664  0059                    DCB32IN:      equ 59h          ;    Input Register                        (RW)
   665  005A                    DCB32OU:      equ 5Ah          ;   Output Register                        (RW)
   666                          
   667                          ; Digital PSoC block 33, Communications Type B
   668  005C                    DCB33FN:      equ 5Ch          ; Function Register                        (RW)
   669  005D                    DCB33IN:      equ 5Dh          ;    Input Register                        (RW)
   670  005E                    DCB33OU:      equ 5Eh          ;   Output Register                        (RW)
   671                          
   672                          ;------------------------------------------------
   673                          ;  System and Global Resource Registers
   674                          ;  Note: Also see this address range in Bank 0.
   675                          ;------------------------------------------------
   676                          
   677  0060                    CLK_CR0:      equ 60h          ; Analog Column Clock Select Register 0    (RW)
   678  00C0                    CLK_CR0_ACOLUMN_3:    equ 0C0h    ; MASK: Specify clock for analog cloumn
   679  0030                    CLK_CR0_ACOLUMN_2:    equ 30h    ; MASK: Specify clock for analog cloumn
   680  000C                    CLK_CR0_ACOLUMN_1:    equ 0Ch    ; MASK: Specify clock for analog cloumn
   681  0003                    CLK_CR0_ACOLUMN_0:    equ 03h    ; MASK: Specify clock for analog cloumn
   682                          
   683  0061                    CLK_CR1:      equ 61h          ; Analog Clock Source Select Register 1    (RW)
   684  0040                    CLK_CR1_SHDIS:        equ 40h    ; MASK: Sample and Hold Disable (all Columns)
   685  0038                    CLK_CR1_ACLK1:        equ 38h    ; MASK: Digital PSoC block for analog source
   686  0007                    CLK_CR1_ACLK2:        equ 07h    ; MASK: Digital PSoC block for analog source
   687                          
   688  0062                    ABF_CR0:      equ 62h          ; Analog Output Buffer Control Register 0  (RW)
   689  0080                    ABF_CR0_ACOL1MUX:     equ 80h    ; MASK: Analog Column 1 Mux control
   690  0040                    ABF_CR0_ACOL2MUX:     equ 40h    ; MASK: Analog Column 2 Mux control
   691  0020                    ABF_CR0_ABUF1EN:      equ 20h    ; MASK: Enable ACol 1 analog buffer (P0[5])
   692  0010                    ABF_CR0_ABUF2EN:      equ 10h    ; MASK: Enable ACol 2 analog buffer (P0[4])
   693  0008                    ABF_CR0_ABUF0EN:      equ 08h    ; MASK: Enable ACol 0 analog buffer (P0[3])
   694  0004                    ABF_CR0_ABUF3EN:      equ 04h    ; MASK: Enable ACol 3 analog buffer (P0[2])
   695  0002                    ABF_CR0_BYPASS:       equ 02h    ; MASK: Bypass the analog buffers
   696  0001                    ABF_CR0_PWR:          equ 01h    ; MASK: High power mode on all analog buffers
   697                          
   698  0063                    AMD_CR0:      equ 63h          ; Analog Modulator Control Register 0      (RW)
   699  0070                    AMD_CR0_AMOD2:        equ 70h    ; MASK: Modulation source for analog column 2
   700  0007                    AMD_CR0_AMOD0:        equ 07h    ; MASK: Modulation source for analog column 1
   701                          
   702  0066                    AMD_CR1:      equ 66h          ; Analog Modulator Control Register 1      (RW)
   703  0070                    AMD_CR1_AMOD3:        equ 70h    ; MASK: Modulation ctrl for analog column 3
   704  0007                    AMD_CR1_AMOD1:        equ 07h    ; MASK: Modulation ctrl for analog column 1
   705                          
   706  0067                    ALT_CR0:      equ 67h          ; Analog Look Up Table (LUT) Register 0    (RW)
   707  00F0                    ALT_CR0_LUT1:         equ 0F0h    ; MASK: Look up table 1 selection
   708  000F                    ALT_CR0_LUT0:         equ 0Fh    ; MASK: Look up table 0 selection
   709                          
   710  0068                    ALT_CR1:      equ 68h          ; Analog Look Up Table (LUT) Register 1    (RW)
   711  00F0                    ALT_CR1_LUT3:         equ 0F0h    ; MASK: Look up table 3 selection
   712  000F                    ALT_CR1_LUT2:         equ 0Fh    ; MASK: Look up table 2 selection
   713                          
   714  0069                    CLK_CR2:      equ 69h          ; Analog Clock Source Control Register 2   (RW)
   715  0008                    CLK_CR2_ACLK1R:       equ 08h    ; MASK: Analog Clock 1 selection range
   716  0001                    CLK_CR2_ACLK0R:       equ 01h    ; MASK: Analog Clock 0 selection range
   717                          
   718                          ;------------------------------------------------
   719                          ;  Global Digital Interconnects
   720                          ;------------------------------------------------
   721                          
   722  00D0                    GDI_O_IN:     equ 0D0h          ; Global Dig Interconnect Odd Inputs Reg   (RW)
   723  00D1                    GDI_E_IN:     equ 0D1h          ; Global Dig Interconnect Even Inputs Reg  (RW)
   724  00D2                    GDI_O_OU:     equ 0D2h          ; Global Dig Interconnect Odd Outputs Reg  (RW)
   725  00D3                    GDI_E_OU:     equ 0D3h          ; Global Dig Interconnect Even Outputs Reg (RW)
   726                          
   727                          ;------------------------------------------------
   728                          ;  Clock and System Control Registers
   729                          ;------------------------------------------------
   730                          
   731  00DD                    OSC_GO_EN:    equ 0DDh          ; Oscillator to Global Outputs Enable Register (RW)
   732  0080                    OSC_GOEN_SLPINT:      equ 80h	 ; Enable Sleep Timer onto GOE[7]
   733  0040                    OSC_GOEN_VC3:         equ 40h    ; Enable VC3 onto GOE[6]
   734  0020                    OSC_GOEN_VC2:         equ 20h    ; Enable VC2 onto GOE[5]
   735  0010                    OSC_GOEN_VC1:         equ 10h    ; Enable VC1 onto GOE[4]
   736  0008                    OSC_GOEN_SYSCLKX2:    equ 08h    ; Enable 2X SysClk onto GOE[3]
   737  0004                    OSC_GOEN_SYSCLK:      equ 04h    ; Enable 1X SysClk onto GOE[2]
   738  0002                    OSC_GOEN_CLK24M:      equ 02h    ; Enable 24 MHz clock onto GOE[1]
   739  0001                    OSC_GOEN_CLK32K:      equ 01h    ; Enable 32 kHz clock onto GOE[0]
   740                          
   741  00DE                    OSC_CR4:      equ 0DEh          ; Oscillator Control Register 4            (RW)
   742  0003                    OSC_CR4_VC3:          equ 03h    ; MASK: System VC3 Clock source
   743                          
   744  00DF                    OSC_CR3:      equ 0DFh          ; Oscillator Control Register 3            (RW)
   745                          
   746  00E0                    OSC_CR0:      equ 0E0h          ; System Oscillator Control Register 0     (RW)
   747  0080                    OSC_CR0_32K_SELECT:   equ 80h    ; MASK: Enable/Disable External XTAL Osc
   748  0040                    OSC_CR0_PLL_MODE:     equ 40h    ; MASK: Enable/Disable PLL
   749  0020                    OSC_CR0_NO_BUZZ:      equ 20h    ; MASK: Bandgap always powered/BUZZ bandgap
   750  0018                    OSC_CR0_SLEEP:        equ 18h    ; MASK: Set Sleep timer freq/period
   751  0000                    OSC_CR0_SLEEP_512Hz:  equ 00h    ;     Set sleep bits for 1.95ms period
   752  0008                    OSC_CR0_SLEEP_64Hz:   equ 08h    ;     Set sleep bits for 15.6ms period
   753  0010                    OSC_CR0_SLEEP_8Hz:    equ 10h    ;     Set sleep bits for 125ms period
   754  0018                    OSC_CR0_SLEEP_1Hz:    equ 18h    ;     Set sleep bits for 1 sec period
   755  0007                    OSC_CR0_CPU:          equ 07h    ; MASK: Set CPU Frequency
   756  0000                    OSC_CR0_CPU_3MHz:     equ 00h    ;     set CPU Freq bits for 3MHz Operation
   757  0001                    OSC_CR0_CPU_6MHz:     equ 01h    ;     set CPU Freq bits for 6MHz Operation
   758  0002                    OSC_CR0_CPU_12MHz:    equ 02h    ;     set CPU Freq bits for 12MHz Operation
   759  0003                    OSC_CR0_CPU_24MHz:    equ 03h    ;     set CPU Freq bits for 24MHz Operation
   760  0004                    OSC_CR0_CPU_1d5MHz:   equ 04h    ;     set CPU Freq bits for 1.5MHz Operation
   761  0005                    OSC_CR0_CPU_750kHz:   equ 05h    ;     set CPU Freq bits for 750kHz Operation
   762  0006                    OSC_CR0_CPU_187d5kHz: equ 06h    ;     set CPU Freq bits for 187.5kHz Operation
   763  0007                    OSC_CR0_CPU_93d7kHz:  equ 07h    ;     set CPU Freq bits for 93.7kHz Operation
   764                          
   765  00E1                    OSC_CR1:      equ 0E1h          ; System VC1/VC2 Divider Control Register  (RW)
   766  00F0                    OSC_CR1_VC1:          equ 0F0h    ; MASK: System VC1 24MHz/External Clk divider
   767  000F                    OSC_CR1_VC2:          equ 0Fh    ; MASK: System VC2 24MHz/External Clk divider
   768                          
   769  00E2                    OSC_CR2:      equ 0E2h          ; Oscillator Control Register 2            (RW)
   770  0004                    OSC_CR2_EXTCLKEN:     equ 04h    ; MASK: Enable/Disable External Clock
   771  0002                    OSC_CR2_IMODIS:       equ 02h    ; MASK: Enable/Disable System (IMO) Clock Net
   772  0001                    OSC_CR2_SYSCLKX2DIS:  equ 01h    ; MASK: Enable/Disable 48MHz clock source
   773                          
   774  00E3                    VLT_CR:       equ 0E3h          ; Voltage Monitor Control Register         (RW)
   775  0080                    VLT_CR_SMP:           equ 80h    ; MASK: Enable Switch Mode Pump
   776  0030                    VLT_CR_PORLEV:        equ 30h    ; MASK: Mask for Power on Reset level control
   777  0000                    VLT_CR_POR_LOW:       equ 00h    ;   Lowest  Precision Power-on Reset trip point
   778  0010                    VLT_CR_POR_MID:       equ 10h    ;   Middle  Precision Power-on Reset trip point
   779  0020                    VLT_CR_POR_HIGH:      equ 20h    ;   Highest Precision Power-on Reset trip point
   780  0008                    VLT_CR_LVDTBEN:       equ 08h    ; MASK: Enable the CPU Throttle Back on LVD
   781  0007                    VLT_CR_VM:            equ 07h    ; MASK: Mask for Voltage Monitor level setting
   782  0000                    VLT_CR_3V0_POR:       equ 00h    ; -- deprecated symbols --
   783  0010                    VLT_CR_4V5_POR:       equ 10h    ;    deprecated
   784  0020                    VLT_CR_4V75_POR:      equ 20h    ;    deprecated
   785  0030                    VLT_CR_DISABLE:       equ 30h    ;    deprecated
   786                          
   787  00E4                    VLT_CMP:      equ 0E4h          ; Voltage Monitor Comparators Register     (R)
   788  0004                    VLT_CMP_PUMP:         equ 04h    ; MASK: Vcc below SMP trip level
   789  0002                    VLT_CMP_LVD:          equ 02h    ; MASK: Vcc below LVD trip level
   790  0001                    VLT_CMP_PPOR:         equ 01h    ; MASK: Vcc below PPOR trip level
   791                          
   792  00E7                    DEC_CR2:      equ 0E7h          ; Decimator Control Register 2             (RW)
   793  00E8                    IMO_TR:       equ 0E8h          ; Internal Main Oscillator Trim Register   (W)
   794  00E9                    ILO_TR:       equ 0E9h          ; Internal Low-speed Oscillator Trim       (W)
   795  00EA                    BDG_TR:       equ 0EAh          ; Band Gap Trim Register                   (W)
   796  00EB                    ECO_TR:       equ 0EBh          ; External Oscillator Trim Register        (W)
   797                          
   798                          ;;=============================================================================
   799                          ;;      M8C System Macros
   800                          ;;  These macros should be used when their functions are needed.
   801                          ;;=============================================================================
   802                          
   803                          ;----------------------------------------------------
   804                          ;  Swapping Register Banks
   805                          ;----------------------------------------------------
   806                              macro M8C_SetBank0
   807                              and   F, ~FLAG_XIO_MASK
   808  7D3C                        endm
   809                          
   810                              macro M8C_SetBank1
   811                              or    F, FLAG_XIO_MASK
   812  7D3C                        endm
   813                          
   814                          ;----------------------------------------------------
   815                          ;  Global Interrupt Enable/Disable
   816                          ;----------------------------------------------------
   817                              macro M8C_EnableGInt
   818                              or    F, FLAG_GLOBAL_IE
   819  7D3C                        endm
   820                          
   821                              macro M8C_DisableGInt
   822                              and   F, ~FLAG_GLOBAL_IE
   823  7D3C                        endm
   824                          
   825                          ;----------------------------------------------------
   826                          ;  Enable/Disable Interrupt Mask
   827                          ;
   828                          ;  Use the following macros to enable/disable
   829                          ;  bits in the Interrupt mask registers,
   830                          ;  INT_MSK0, INT_MSK1 or INT_MSK3.
   831                          ;
   832                          ;  Usage:    M8C_DisableIntMask INT_MSKN, MASK
   833                          ;            M8C_EnableIntMask  INT_MSKN, MASK
   834                          ;
   835                          ;  where INT_MSKN is INT_MSK0, INT_MSK1 or INT_MSK3
   836                          ;        and MASK is the bit set to enable or disable
   837                          ;----------------------------------------------------
   838                          ; Disable Interrupt Bit Mask(s)
   839                              macro M8C_DisableIntMask
   840                              and   reg[@0], ~@1              ; disable specified interrupt enable bit
   841  7D3C                        endm
   842                          
   843                          ; Enable Interrupt Bit Mask(s)
   844                              macro M8C_EnableIntMask
   845                              or    reg[@0], @1               ; enable specified interrupt enable bit
   846  7D3C                        endm
   847                          
   848                          ;----------------------------------------------------
   849                          ;  Clear Posted Interrupt Flag Mask
   850                          ;
   851                          ;  Use the following macros to clear the
   852                          ;  bits in the Interrupt Clear registers,
   853                          ;  INT_CLR0, INT_CLR1 or INT_CLR3.
   854                          ;  Usage:    M8C_ClearIntFlag INT_CLRN, MASK
   855                          ;
   856                          ;  where INT_MSKN is INT_CLR0, INT_CLR1 or INT_CLR3
   857                          ;        and MASK is the bit set to enable or disable
   858                          ;----------------------------------------------------
   859                              macro M8C_ClearIntFlag
   860                              mov   reg[@0], ~@1              ; clear specified interrupt enable bit
   861  7D3C                        endm
   862                          
   863                          ;----------------------------------------------------
   864                          ;  Power-On Reset & WatchDog Timer Functions
   865                          ;----------------------------------------------------
   866                              macro M8C_EnableWatchDog
   867                              and   reg[CPU_SCR0], ~CPU_SCR0_PORS_MASK
   868  7D3C                        endm
   869                          
   870                              macro M8C_ClearWDT
   871                              mov   reg[RES_WDT], 00h
   872  7D3C                        endm
   873                          
   874                              macro M8C_ClearWDTAndSleep
   875                              mov   reg[RES_WDT], 38h
   876  7D3C                        endm
   877                          
   878                          ;----------------------------------------------------
   879                          ;  CPU Stall for Analog PSoC Block Writes
   880                          ;----------------------------------------------------
   881                              macro M8C_Stall
   882                              or    reg[ASY_CR], ASY_CR_SYNCEN
   883  7D3C                        endm
   884                          
   885                              macro M8C_Unstall
   886                              and   reg[ASY_CR], ~ASY_CR_SYNCEN
   887  7D3C                        endm
   888                          
   889                          ;----------------------------------------------------
   890                          ;  Sleep, CPU Stop & Software Reset
   891                          ;----------------------------------------------------
   892                              macro M8C_Sleep
   893                              or    reg[CPU_SCR0], CPU_SCR0_SLEEP_MASK
   894                              ; The next instruction to be executed depends on the state of the
   895                              ; various interrupt enable bits. If some interrupts are enabled
   896                              ; and the global interrupts are disabled, the next instruction will
   897                              ; be the one that follows the invocation of this macro. If global
   898                              ; interrupts are also enabled then the next instruction will be
   899                              ; from the interrupt vector table. If no interrupts are enabled
   900                              ; then the CPU sleeps forever.
   901  7D3C                        endm
   902                          
   903                              macro M8C_Stop
   904                              ; In general, you probably don't want to do this, but here's how:
   905                              or    reg[CPU_SCR0], CPU_SCR0_STOP_MASK
   906                              ; Next instruction to be executed is located in the interrupt
   907                              ; vector table entry for Power-On Reset.
   908  7D3C                        endm
   909                          
   910                              macro M8C_Reset
   911                              ; Restore CPU to the power-on reset state.
   912                              mov A, 0
   913                              SSC
   914                              ; Next non-supervisor instruction will be at interrupt vector 0.
   915  7D3C                        endm
   916                          
   917                          ;----------------------------------------------------
   918                          ; ImageCraft Code Compressor Actions
   919                          ;----------------------------------------------------
   920                              ; Suspend Code Compressor
   921                              ; Must not span a RET or RETI instruction
   922                              ; without resuming code compression
   923                              macro Suspend_CodeCompressor
   924                              or   F, 0
   925  7D3C                        endm
   926                          
   927                              ; Resume Code Compression
   928                              macro Resume_CodeCompressor
   929                              add  SP, 0
   930  7D3C                        endm
     1                          ;;*****************************************************************************
     2                          ;;*****************************************************************************
     3                          ;;
     4                          ;;       FILENAME: Memory.inc
     5                          ;;
     6                          ;;    DESCRIPTION: Memory Model and Stack Parameter Definitions for 
     7                          ;;                 the 29xxx family of PSoC devices.
     8                          ;;
     9                          ;;  LAST MODIFIED: June 17, 2004
    10                          ;;
    11                          ;;-----------------------------------------------------------------------------
    12                          ;;  Copyright (c) Cypress MicroSystems 2004. All Rights Reserved.
    13                          ;;*****************************************************************************
    14                          ;;*****************************************************************************
    15                          
    16                          
    17                          ;  ******** Define Memory Model and Stack parameters ********
    18                          ;
    19  0001                    IMAGECRAFT: equ 1   
    20  0002                    HITECH: equ 2   
    21  0002                    TOOLCHAIN: equ HITECH   
    22  0001                    SYSTEM_LARGE_MEMORY_MODEL: equ 1   
    23  0000                    SYSTEM_SMALL_MEMORY_MODEL: equ 0   
    24  0007                    SYSTEM_STACK_PAGE: equ 7   
    25  0000                    SYSTEM_STACK_PAGE_OFFSET: equ 0   
    26  0002                    SYSTEM_TOOLS: equ 2   
    27  0000                    SYSTEM_IDXPG_TRACKS_STK_PP: equ 0   
    28  0001                    SYSTEM_IDXPG_TRACKS_IDX_PP: equ 1   
    29  0000                    SYSTEM_MULTIPAGE_STACK: equ 0 
    30                          
    31                          
    32                          ;  ******* Function Class Definitions *******
    33                          ;
    34                          ;  These definitions are used to describe RAM access patterns. They provide
    35                          ;  documentation and they control prologue and epilogue macros that perform
    36                          ;  the necessary housekeeping functions for large memory model devices like
    37                          ;  the CY8C27x66 and CY8C29x66.
    38                          
    39  0001                    RAM_USE_CLASS_1:               equ 1   ; PUSH, POP & I/O access
    40  0002                    RAM_USE_CLASS_2:               equ 2   ; Indexed address mode on stack page
    41  0004                    RAM_USE_CLASS_3:               equ 4   ; Indexed address mode to any page
    42  0008                    RAM_USE_CLASS_4:               equ 8   ; Direct/Indirect address mode access
    43                          
    44                          
    45                          ;  ******* Page Pointer Manipulation Macros *******
    46                          ;
    47                          ;  Most of the following macros are conditionally compiled so they only
    48                          ;  produce code if the large memory model is selected.
    49                          
    50                             ;-----------------------------------------------
    51                             ;  Set Stack Page Macro
    52                             ;-----------------------------------------------
    53                             ;
    54                             ;  DESC: Modify STK_PP in the large or small memory Models.
    55                             ;
    56                             ; INPUT: Constant (e.g., SYSTEM_STACK_PAGE) that specifies the RAM page on
    57                             ;        which stack operations like PUSH and POP store and retrieve their
    58                             ;        data
    59                             ;
    60                             ;  COST: 8 instruction cycles (in LMM only)
    61                          
    62                             macro RAM_SETPAGE_STK( PG_NUMBER )
    63                             IF ( SYSTEM_LARGE_MEMORY_MODEL )
    64                                mov reg[STK_PP], @PG_NUMBER
    65                             ENDIF
    66  7D3C                       endm
    67                          
    68                             ;-----------------------------------------------
    69                             ;  Set Current Page Macro
    70                             ;-----------------------------------------------
    71                             ;
    72                             ;  DESC: Modify CUR_PP in the large or small memory Models.
    73                             ;
    74                             ; INPUT: Constant value (e.g., >bFoo) for the RAM page number used in
    75                             ;        calculation of effective direct-mode address operands.
    76                             ;
    77                             ;  COST: 8 instruction cycles (in LMM only)
    78                          
    79                             macro RAM_SETPAGE_CUR( PG_NUMBER )
    80                             IF ( SYSTEM_LARGE_MEMORY_MODEL )
    81                                mov reg[CUR_PP], @PG_NUMBER
    82                             ENDIF
    83  7D3C                       endm
    84                          
    85                             ;-----------------------------------------------
    86                             ;  Set Index Page Macro
    87                             ;-----------------------------------------------
    88                             ;
    89                             ;  DESC: Modify IDX_PP in the large or small emory Models.
    90                             ;
    91                             ; INPUT: Constant value (e.g., >caFoo) for the RAM page number used in
    92                             ;         calculation of effective index-mode address operands.
    93                             ;
    94                             ;  COST: 8 instruction cycles (in LMM only)
    95                          
    96                             macro RAM_SETPAGE_IDX( PG_NUMBER )
    97                             IF ( SYSTEM_LARGE_MEMORY_MODEL )
    98                                mov reg[IDX_PP], @PG_NUMBER
    99                             ENDIF
   100  7D3C                       endm
   101                          
   102                             ;-----------------------------------------------
   103                             ;  Set MVI Read Page Macro
   104                             ;-----------------------------------------------
   105                             ;
   106                             ;  DESC: Modify MVR_PP in the large or small memory Models.
   107                             ;
   108                             ; INPUT: Constant value (e.g., >pFoo) for the RAM page number used in
   109                             ;        calculation of indirect address operands used in the
   110                             ;        "mvi A, [pFoo]" instructions.
   111                             ;
   112                             ;  COST: 8 instruction cycles (in LMM only)
   113                          
   114                             macro RAM_SETPAGE_MVR( PG_NUMBER )
   115                             IF ( SYSTEM_LARGE_MEMORY_MODEL )
   116                                mov reg[MVR_PP], @PG_NUMBER
   117                             ENDIF
   118  7D3C                       endm
   119                          
   120                             ;-----------------------------------------------
   121                             ;  Set MVI Write Page Macro
   122                             ;-----------------------------------------------
   123                             ;
   124                             ;  DESC: Modify MVW_PP in the large or small memory Models.
   125                             ;
   126                             ; INPUT: Constant value (e.g., >pFoo) for the RAM page number used in
   127                             ;        calculation of indirect address operands used in the
   128                             ;        "mvi [pFoo], A" instructions.
   129                             ;
   130                             ;  COST: 8 instruction cycles (in LMM only)
   131                          
   132                             macro RAM_SETPAGE_MVW( PG_NUMBER )
   133                             IF ( SYSTEM_LARGE_MEMORY_MODEL )
   134                                mov reg[MVW_PP], @PG_NUMBER
   135                             ENDIF
   136  7D3C                       endm
   137                          
   138                             ;-----------------------------------------------
   139                             ;  Force Index Page Pointer to Stack Page
   140                             ;-----------------------------------------------
   141                             ;
   142                             ;  DESC: Map index-mode operands onto the stack page by modifying IDX_PP.
   143                             ;        See also RAM_LOCK_INDEX_TO_STACKPAGE.
   144                             ;
   145                             ; INPUT: None
   146                             ;
   147                             ;  COST: 8 instruction cycles (in LMM only)
   148                          
   149                             macro RAM_SETPAGE_IDX2STK
   150                             IF ( SYSTEM_LARGE_MEMORY_MODEL )
   151                                IF ( SYSTEM_MULTIPAGE_STACK )
   152                                   mov   A, reg[STK_PP]
   153                                   mov   reg[IDX_PP], A
   154                                ELSE
   155                                   RAM_SETPAGE_IDX SYSTEM_STACK_PAGE
   156                                ENDIF
   157                             ENDIF
   158  7D3C                       endm
   159                          
   160                             ;-----------------------------------------------
   161                             ;  Change Memory Mode
   162                             ;-----------------------------------------------
   163                             ;
   164                             ;  DESC: Modify FLAG_PAGEMODE bits in the large and small memory Models.
   165                             ;
   166                             ; INPUT: Constant value for PGMODE bitfield of CPU Flag register, F.
   167                             ;        See FLAG_PGMODE_{x} constants in M8C.INC.
   168                             ;
   169                             ;  COST: 8 instruction cycles (in LMM only)
   170                          
   171                             macro RAM_CHANGE_PAGE_MODE( MODE )
   172                             IF ( SYSTEM_LARGE_MEMORY_MODEL )
   173                                and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
   174                                or    F,  FLAG_PGMODE_MASK & @MODE
   175                             ENDIF
   176  7D3C                       endm
   177                          
   178                             ;-----------------------------------------------
   179                             ;  Set Large Memory Model Native Paging Mode
   180                             ;-----------------------------------------------
   181                             ;
   182                             ;  DESC: Changes the FLAG_PAGEMODE bits to enter the native LMM RAM
   183                             ;        paging mode *IFF* a simple "OR" is guaranteed to work---for
   184                             ;        example, in an ISR, when the PGMODE bits have been cleared
   185                             ;        to zero. If a simple "OR" is not guaranteed to work, use
   186                             ;        the slower RAM_RESTORE_NATIVE_PAGING instead.
   187                             ;
   188                             ; INPUT: none
   189                             ;
   190                             ;  COST: 4 instruction cycles (in LMM only)
   191                          
   192                             macro RAM_SET_NATIVE_PAGING
   193                             IF ( SYSTEM_LARGE_MEMORY_MODEL )
   194                             IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
   195                                or    F,  FLAG_PGMODE_11b            ; LMM w/ IndexPage<==>StackPage
   196                             ENDIF ;  PGMODE LOCKED
   197                             IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
   198                                or    F,  FLAG_PGMODE_10b            ; LMM with independent IndexPage
   199                             ENDIF ; PGMODE FREE
   200                             ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
   201  7D3C                       endm
   202                          
   203                             ;-----------------------------------------------
   204                             ; Restore Large Memory Model Native Paging Mode
   205                             ;-----------------------------------------------
   206                             ;
   207                             ;  DESC: Changes the FLAG_PAGEMODE bits to enter the native LMM RAM
   208                             ;        paging mode. Always works because it clears the PGMODE bits
   209                             ;        before OR-ing in the new ones. See RAM_RESTORE_NATIVE_PAGING
   210                             ;        for a faster method.
   211                             ;
   212                             ; INPUT: none
   213                             ;
   214                             ;  COST: 8 instruction cycles (in LMM only)
   215                          
   216                             macro RAM_RESTORE_NATIVE_PAGING
   217                             IF ( SYSTEM_LARGE_MEMORY_MODEL )
   218                             IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
   219                                RAM_CHANGE_PAGE_MODE FLAG_PGMODE_11b ; LMM w/ IndexPage<==>StackPage
   220                             ENDIF ;  PGMODE LOCKED
   221                             IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
   222                                RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b ; LMM with independent IndexPage
   223                             ENDIF ; PGMODE FREE
   224                             ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
   225  7D3C                       endm
   226                          
   227                             ;-----------------------------------------------
   228                             ; Force indexed addr mode operands to Stack Pg
   229                             ;-----------------------------------------------
   230                             ;
   231                             ;  DESC: Force instructions that use indexed address mode to reference the
   232                             ;        stack page (as defined by STK_PP). This macro sets the "Indexed
   233                             ;        Stack Mode" bit (LSB) of the PGMODE bit field in the CPU Flag
   234                             ;        register, F. (See also RAM_SETPAGE_IDX2STK, above.)
   235                             ;
   236                             ; INPUT: none
   237                             ;
   238                             ;  COST: 4 instruction cycles (in LMM only)
   239                          
   240                             macro RAM_X_POINTS_TO_STACKPAGE
   241                             IF ( SYSTEM_LARGE_MEMORY_MODEL )
   242                                or   F, FLAG_PGMODE_01b
   243                             ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
   244  7D3C                       endm
   245                          
   246                             ;-----------------------------------------------
   247                             ;  Force indexed addr mode operands to Index Pg
   248                             ;-----------------------------------------------
   249                             ;
   250                             ;  DESC: Permit instructions that use indexed address mode to reference page
   251                             ;        zero or the page pointed to by the IDX_PP register, depending on the
   252                             ;        setting of the MSb (or "Direct Page Mode" bit) of the PGMODE bits
   253                             ;        in the CPU Flag register, F. (This macro clears the PGMODE LSb.)
   254                             ;
   255                             ; INPUT: none
   256                             ;
   257                             ;  COST: 4 instruction cycles (in LMM only)
   258                          
   259                             macro RAM_X_POINTS_TO_INDEXPAGE
   260                             IF ( SYSTEM_LARGE_MEMORY_MODEL )
   261                                and  F, ~FLAG_PGMODE_01b
   262                             ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
   263  7D3C                       endm
   264                          
   265                             ;-----------------------------------------------
   266                             ;  Function Prologue
   267                             ;-----------------------------------------------
   268                             ;
   269                             ;  Prologue for functions that run in the LMM and SMM.
   270                             ;
   271                          
   272                             macro RAM_PROLOGUE( ACTUAL_CLASS )
   273                          
   274                             IF ( @ACTUAL_CLASS & RAM_USE_CLASS_1 )
   275                             ; Nothing to do
   276                             ENDIF ; RAM_USE_CLASS_1
   277                          
   278                             IF ( @ACTUAL_CLASS & RAM_USE_CLASS_2 )
   279                                IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
   280                                   RAM_X_POINTS_TO_STACKPAGE         ; exit native paging mode!
   281                                ENDIF
   282                             ENDIF ; RAM_USE_CLASS_2
   283                          
   284                             IF ( @ACTUAL_CLASS & RAM_USE_CLASS_3 )
   285                                IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
   286                                   RAM_X_POINTS_TO_INDEXPAGE         ; exit native paging mode!
   287                                ENDIF
   288                             ENDIF ; RAM_USE_CLASS_3
   289                          
   290                             IF ( @ACTUAL_CLASS & RAM_USE_CLASS_4 )
   291                             ; Nothing to do
   292                             ENDIF ; RAM_USE_CLASS_4
   293                          
   294  7D3C                       endm
   295                          
   296                             ;-----------------------------------------------
   297                             ;  Function Epilogue
   298                             ;-----------------------------------------------
   299                             ;
   300                             ;  Prologue for functions that run in the LMM and SMM.
   301                             ;
   302                          
   303                             macro RAM_EPILOGUE( ACTUAL_CLASS )
   304                          
   305                             IF ( @ACTUAL_CLASS & RAM_USE_CLASS_1 )
   306                             ; Nothing to do
   307                             ENDIF ; RAM_USE_CLASS_1
   308                          
   309                             IF ( @ACTUAL_CLASS & RAM_USE_CLASS_2 )
   310                                RAM_RESTORE_NATIVE_PAGING
   311                             ENDIF ; RAM_USE_CLASS_2
   312                          
   313                             IF ( @ACTUAL_CLASS & RAM_USE_CLASS_3 )
   314                                RAM_RESTORE_NATIVE_PAGING
   315                             ENDIF ; RAM_USE_CLASS_3
   316                          
   317                             IF ( @ACTUAL_CLASS & RAM_USE_CLASS_4 )
   318                             ; Nothing to do
   319                             ENDIF ; RAM_USE_CLASS_4
   320                          
   321  7D3C                       endm
   322                          
   323                             ;-----------------------------------------------
   324                             ;  Preserve Register
   325                             ;-----------------------------------------------
   326                             ;
   327                             ;  DESC: Preserve a register value on the stack
   328                             ;
   329                             ; INPUT: Name or address of register in I/O Space
   330                             ;        The I/O bank is an implicit parameter. That is, this function will
   331                             ;        Access the I/O bank currently specified by the CPU Flag register.
   332                             ;
   333                             ;  USES: CPU 'A' register
   334                             ;
   335                             ;  COST: 9 instruction cycles
   336                          
   337                             macro REG_PRESERVE( IOReg )
   338                             mov   A, reg[ @IOReg ]
   339                             push  A
   340  7D3C                       endm
   341                          
   342                             ;-----------------------------------------------
   343                             ;  Restore Register
   344                             ;-----------------------------------------------
   345                             ;
   346                             ;  DESC: Restore a register value from the stack
   347                             ;
   348                             ; INPUT: Name or address of register in I/O Space
   349                             ;        The I/O bank is an implicit parameter. That is, this function will
   350                             ;        Access the I/O bank currently specified by the CPU Flag register.
   351                             ;
   352                             ;  USES: CPU 'A' register
   353                             ;
   354                             ;  COST: 10 instruction cycles
   355                          
   356                             macro REG_RESTORE( IOReg )
   357                             pop   A
   358                             mov   reg[ @IOReg ], A
   359  7D3C                       endm
   360                          
   361                             ;-----------------------------------------------
   362                             ;  Preserve Volatile Page Pointer Registers
   363                             ;-----------------------------------------------
   364                             ;
   365                             ;  DESC: Invoked by ISRs before switching to the LMM mode and calling
   366                             ;        functions that require on it.
   367                             ;
   368                             ; INPUT: none
   369                             ;
   370                             ;  USES: CPU 'A' register
   371                             ;
   372                             ;  COST: 45 instruction cycles (in LMM only)
   373                          
   374                             macro ISR_PRESERVE_PAGE_POINTERS
   375                             IF ( SYSTEM_LARGE_MEMORY_MODEL )
   376                                REG_PRESERVE CUR_PP
   377                                REG_PRESERVE IDX_PP
   378                                REG_PRESERVE MVR_PP
   379                                REG_PRESERVE MVW_PP
   380                             ENDIF
   381  7D3C                       endm
   382                          
   383                             ;-----------------------------------------------
   384                             ;  Restore Volatile Page Pointer Registers
   385                             ;-----------------------------------------------
   386                             ;
   387                             ;  DESC: Undo for RAM_PRESERVE_PAGE_POINTERS macro. Invoked by ISRs after
   388                             ;        calling functions that run in the LMM mode and before executing
   389                             ;        the RETI instruction.
   390                             ;
   391                             ; INPUT: none
   392                             ;
   393                             ;  USES: CPU 'A' register
   394                             ;
   395                             ;  COST: 50 instruction cycles (in LMM only)
   396                          
   397                             macro ISR_RESTORE_PAGE_POINTERS
   398                             IF ( SYSTEM_LARGE_MEMORY_MODEL )
   399                                REG_RESTORE MVW_PP
   400                                REG_RESTORE MVR_PP
   401                                REG_RESTORE IDX_PP
   402                                REG_RESTORE CUR_PP
   403                             ENDIF
   404  7D3C                       endm
     1                          ;;*****************************************************************************
     2                          ;;*****************************************************************************
     3                          ;;  FILENAME:   LTRX.inc
     4                          ;;  Version: 5.2, Updated on 2008/6/23 at 12:26:23
     5                          ;;  Generated by PSoC Designer ???
     6                          ;;
     7                          ;;  DESCRIPTION:  Assembler declarations for the UART user module for the
     8                          ;;                22/24/25/26/27xxx PSoC family of devices.
     9                          ;;-----------------------------------------------------------------------------
    10                          ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
    11                          ;;*****************************************************************************
    12                          ;;*****************************************************************************
    13                          
    14                          ;--------------------------------------------------
    15                          ; Constants for LTRX API's
    16                          ;--------------------------------------------------
    17                          
    18                          ;mask value for global int reg bit for TX instance
    19  0040                    LTRX_TX_INT_MASK:                            equ 0x40
    20  00E1                    LTRX_TX_INT_REG:                             equ 0x0e1  ;TX interrupt address
    21  0080                    LTRX_RX_INT_MASK:                            equ 0x80  ;mask value for global int reg bit for RX ins
                                tance
    22  00E1                    LTRX_RX_INT_REG:                             equ 0x0e1  ;RX interrupt address
    23                          
    24  0001                    LTRX_RXBUF_ENABLE:                           equ 1
    25                          
    26                          ; Interrupt control masks
    27  0001                    LTRX_ENABLE_RX_INT:                          equ 0x01
    28  0000                    LTRX_DISABLE_RX_INT:                         equ 0x00
    29  0002                    LTRX_ENABLE_TX_INT:                          equ 0x02
    30  0000                    LTRX_DISABLE_TX_INT:                         equ 0x00
    31                          
    32  0000                    LTRX_INT_MODE_TX_REG_EMPTY:                  equ 0x00
    33  0001                    LTRX_INT_MODE_TX_COMPLETE:                   equ 0x01
    34                          
    35  0020                    LTRX_RX_IGNORE_BELOW:                        equ 0x20
    36  0010                    LTRX_RX_BUFFER_SIZE:                         equ 0x10
    37  000D                    LTRX_CMD_TERM:                               equ 0xd
    38  0020                    LTRX_DELIMITER:                              equ 0x20
    39  0000                    LTRX_BACKSPACE_ENABLE:                       equ 0x0
    40                          
    41                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    42                          ;       WARNING WARNING WARNING
    43                          ; The following equates are for backwards
    44                          ; compatibility only and should not be used
    45                          ; for new designs.
    46                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    47                          
    48                          ;------------------------------------
    49                          ;  Parity masks
    50                          ;------------------------------------
    51  0000                    UART_PARITY_NONE:       equ   00h
    52  0002                    UART_PARITY_EVEN:       equ   02h
    53  0006                    UART_PARITY_ODD:        equ   06h
    54                          
    55                          ;------------------------------------
    56                          ;  TX Status Register masks
    57                          ;------------------------------------
    58  0020                    UART_TX_COMPLETE:       equ   20h
    59  0010                    UART_TX_BUFFER_EMPTY:   equ   10h
    60                          
    61                          ;------------------------------------
    62                          ;  RX Status Register masks
    63                          ;------------------------------------
    64  0010                    UART_RX_ACTIVE:         equ   10h
    65  0008                    UART_RX_COMPLETE:       equ   08h
    66  0080                    UART_RX_PARITY_ERROR:   equ   80h
    67  0040                    UART_RX_OVERRUN_ERROR:  equ   40h
    68  0020                    UART_RX_FRAMING_ERROR:  equ   20h
    69  00E0                    UART_RX_NO_ERROR:       equ   E0h
    70                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    71                          ;             END WARNING
    72                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    73                          
    74                          
    75                          
    76                          ;------------------------------------
    77                          ;  Parity masks
    78                          ;------------------------------------
    79  0000                    LTRX_PARITY_NONE:                       equ   00h
    80  0002                    LTRX_PARITY_EVEN:                       equ   02h
    81  0006                    LTRX_PARITY_ODD:                        equ   06h
    82                          
    83                          ;------------------------------------
    84                          ;  TX Status Register masks
    85                          ;------------------------------------
    86  0020                    LTRX_TX_COMPLETE:                       equ   20h
    87  0010                    LTRX_TX_BUFFER_EMPTY:                   equ   10h
    88                          
    89                          ;------------------------------------
    90                          ;  RX Status Register masks
    91                          ;------------------------------------
    92  0010                    LTRX_RX_ACTIVE:                         equ   10h
    93  0008                    LTRX_RX_COMPLETE:                       equ   08h
    94  0008                    LTRX_RX_REG_FULL:                       equ   08h
    95  0080                    LTRX_RX_PARITY_ERROR:                   equ   80h
    96  0040                    LTRX_RX_OVERRUN_ERROR:                  equ   40h
    97  0020                    LTRX_RX_FRAMING_ERROR:                  equ   20h
    98  00E0                    LTRX_RX_ERROR:                          equ   E0h
    99  0001                    LTRX_RX_ENABLE:                         equ   01h
   100                          
   101  00F0                    LTRX_RX_BUF_ERROR:                      equ   F0h  ; Mask for any Rx that may occur.
   102  0010                    LTRX_RX_BUF_OVERRUN:                    equ   10h  ; This indicates the software buffer has
   103                                                                                  ; been over run.
   104  0001                    LTRX_RX_BUF_CMDTERM:                    equ   01h  ; Command terminator has been received.
   105                          
   106  0001                    LTRX_RX_NO_DATA:                        equ   01h
   107  00E0                    LTRX_RX_NO_ERROR:                       equ   E0h
   108                          
   109                          
   110                          ;--------------------------------------------------
   111                          ; Registers Address Constants for LTRX
   112                          ;--------------------------------------------------
   113                          ;---------------------------------
   114                          ;  Registers used by TX
   115                          ;---------------------------------
   116  003B                    LTRX_TX_CONTROL_REG:    equ 3bh            ; Control register
   117  0038                    LTRX_TX_SHIFT_REG:  equ 38h               ; TX Shift Register register
   118  0039                    LTRX_TX_BUFFER_REG: equ 39h               ; TX Buffer Register
   119  0038                    LTRX_TX_FUNC_REG:   equ 38h             ; Function register
   120  0039                    LTRX_TX_INPUT_REG:  equ 39h             ; Input register
   121  003A                    LTRX_TX_OUTPUT_REG: equ 3ah             ; Output register
   122                          
   123                          ;---------------------------------
   124                          ;  Registers used by RX
   125                          ;---------------------------------
   126  003F                    LTRX_RX_CONTROL_REG:    equ 3fh            ; Control register
   127  003C                    LTRX_RX_SHIFT_REG:  equ 3ch               ; RX Shift Register register
   128  003E                    LTRX_RX_BUFFER_REG: equ 3eh               ; RX Buffer Register
   129  003C                    LTRX_RX_FUNC_REG:   equ 3ch             ; Function register
   130  003D                    LTRX_RX_INPUT_REG:  equ 3dh             ; Input register
   131  003E                    LTRX_RX_OUTPUT_REG: equ 3eh             ; Output register
     1                          ;;*****************************************************************************
     2                          ;;*****************************************************************************
     3                          ;;  Filename:   LTRX.asm
     4                          ;;  Version: 5.2, Updated on 2008/6/23 at 12:26:23
     5                          ;;  Generated by PSoC Designer ???
     6                          ;;
     7                          ;;  DESCRIPTION:  UART User Module software implementation file for the
     8                          ;;                22/24/25/26/27xxx families.
     9                          ;;
    10                          ;;
    11                          ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
    12                          ;;        arguments and observe the associated "Registers are volatile" policy.
    13                          ;;        This means it is the caller's responsibility to preserve any values
    14                          ;;        in the X and A registers that are still needed after the API functions
    15                          ;;        returns. For Large Memory Model devices it is also the caller's 
    16                          ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
    17                          ;;        MVW_PP registers. Even though some of these registers may not be modified
    18                          ;;        now, there is no guarantee that will remain the case in future releases.
    19                          ;;-----------------------------------------------------------------------------
    20                          ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
    21                          ;;*****************************************************************************
    22                          ;;*****************************************************************************
    23                          
    24                          
    25                          include "m8c.inc"
    26                          include "memory.inc"
    27                          include "LTRX.inc"
    28                          
    29                          ;-----------------------------------------------
    30                          ;  Global Symbols
    31                          ;-----------------------------------------------
    32                          ;-------------------------------------------------------------------
    33                          ;  Declare the functions global for both assembler and C compiler.
    34                          ;
    35                          ;  Note that there are two names for each API. First name is
    36                          ;  assembler reference. Name with underscore is name refence for
    37                          ;  C compiler.  Calling function in C source code does not require
    38                          ;  the underscore.
    39                          ;-------------------------------------------------------------------
    40                          export  LTRX_SetTxIntMode
    41                          export _LTRX_SetTxIntMode
    42                          export  LTRX_EnableInt
    43                          export _LTRX_EnableInt
    44                          export  LTRX_DisableInt
    45                          export _LTRX_DisableInt
    46                          
    47                          export  LTRX_Start
    48                          export _LTRX_Start
    49                          export  LTRX_Stop
    50                          export _LTRX_Stop
    51                          export  LTRX_SendData
    52                          export _LTRX_SendData
    53                          export  LTRX_bReadTxStatus
    54                          export _LTRX_bReadTxStatus
    55                          export  LTRX_bReadRxData
    56                          export _LTRX_bReadRxData
    57                          export  LTRX_bReadRxStatus
    58                          export _LTRX_bReadRxStatus
    59                          
    60                          export  LTRX_IntCntl
    61                          export _LTRX_IntCntl
    62                          
    63                          export  LTRX_TxIntMode
    64                          export _LTRX_TxIntMode
    65                          
    66                          export  LTRX_PutSHexByte
    67                          export _LTRX_PutSHexByte
    68                          export  LTRX_PutSHexInt
    69                          export _LTRX_PutSHexInt
    70                          
    71                          export  LTRX_CPutString
    72                          export _LTRX_CPutString
    73                          export  LTRX_PutString
    74                          export _LTRX_PutString
    75                          export  LTRX_PutChar
    76                          export _LTRX_PutChar
    77                          export  LTRX_Write
    78                          export _LTRX_Write
    79                          export  LTRX_CWrite
    80                          export _LTRX_CWrite
    81                          
    82                          export  LTRX_cGetChar
    83                          export _LTRX_cGetChar
    84                          export  LTRX_cReadChar
    85                          export _LTRX_cReadChar
    86                          export  LTRX_iReadChar
    87                          export _LTRX_iReadChar
    88                          export  LTRX_PutCRLF
    89                          export _LTRX_PutCRLF
    90                          
    91                          IF (LTRX_RXBUF_ENABLE)
    92                          export  LTRX_CmdReset
    93                          export _LTRX_CmdReset
    94                          export  LTRX_bCmdCheck
    95                          export _LTRX_bCmdCheck
    96                          export  LTRX_bCmdLength
    97                          export _LTRX_bCmdLength
    98                          export  LTRX_bErrCheck
    99                          export _LTRX_bErrCheck
   100                          
   101                          export  LTRX_szGetParam
   102                          export _LTRX_szGetParam
   103                          export  LTRX_szGetRestOfParams
   104                          export _LTRX_szGetRestOfParams
   105                          ENDIF
   106                          
   107                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   108                          ; WARNING WARNING WARNING
   109                          ; The following exports are for backwards compatibility only and should
   110                          ; not be used for new designs. They may be eliminated in a future release.
   111                          ; Their status is "NO FURTHER MAINTENANCE". 
   112                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   113                          export  bLTRX_ReadTxStatus
   114                          export _bLTRX_ReadTxStatus
   115                          export  bLTRX_ReadRxData
   116                          export _bLTRX_ReadRxData
   117                          export  bLTRX_ReadRxStatus
   118                          export _bLTRX_ReadRxStatus
   119                          	
   120                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   121                          ;             END WARNING
   122                          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   123                          
   124                          ;-----------------------------------------------
   125                          ; Variable Allocation
   126                          ;-----------------------------------------------
   127                          IF (LTRX_RXBUF_ENABLE)
   128                              
   129                          area LTRX_RAM (RAM, REL, CON)
   130                              
   131                           ptrParam:   BLK  1
   132                          
   133                          ENDIF
   134                          
   135                          area text (ROM,REL)
   136                          
   137                          ;-----------------------------------------------
   138                          ;  EQUATES
   139                          ;-----------------------------------------------
   140  0001                    bfCONTROL_REG_START_BIT:        equ    1    ; Control register start bit
   141  0010                    bfFUNCTION_REG_TX_INT_MODE_BIT: equ 0x10    ; the TX Int Mode bit
   142                          
   143                          area UserModules (ROM, REL, CON)
   144                          
   145                          ;=============================================================================
   146                          ;=============================================================================
   147                          ;
   148                          ;     Low-Level Commands
   149                          ;
   150                          ;=============================================================================
   151                          ;=============================================================================
   152                          
   153                          .SECTION
   154                          ;-----------------------------------------------------------------------------
   155                          ;  FUNCTION NAME: LTRX_EnableInt
   156                          ;
   157                          ;  DESCRIPTION:
   158                          ;     Enables this UART's interrupt by setting the interrupt enable mask
   159                          ;     bit associated with this User Module. Remember to call the global
   160                          ;     interrupt enable function by using the macro: M8C_EnableGInt.
   161                          ;-----------------------------------------------------------------------------
   162                          ;
   163                          ;  ARGUMENTS:
   164                          ;     none.
   165                          ;
   166                          ;  RETURNS:
   167                          ;     none.
   168                          ;
   169                          ;  SIDE EFFECTS:
   170                          ;    The A and X registers may be modified by this or future implementations
   171                          ;    of this function.  The same is true for all RAM page pointer registers in
   172                          ;    the Large Memory Model.  When necessary, it is the calling function's
   173                          ;    responsibility to perserve their values across calls to fastcall16 
   174                          ;    functions.
   175                          ;
   176  730E                     LTRX_EnableInt:
   177  730E                    _LTRX_EnableInt:
   178                             RAM_PROLOGUE RAM_USE_CLASS_1
   179  730E  43 E1 40             M8C_EnableIntMask LTRX_TX_INT_REG, LTRX_TX_INT_MASK
   180  7311  43 E1 80             M8C_EnableIntMask LTRX_RX_INT_REG, LTRX_RX_INT_MASK
   181                             RAM_EPILOGUE RAM_USE_CLASS_1
   182  7314  7F                   ret
   183                          .ENDSECTION
   184                          
   185                              
   186                          .SECTION
   187                          ;-----------------------------------------------------------------------------
   188                          ;  FUNCTION NAME: LTRX_DisableInt
   189                          ;
   190                          ;  DESCRIPTION:
   191                          ;     Disables this UART's interrupt by clearing the interrupt enable mask bit
   192                          ;     associated with this User Module.
   193                          ;-----------------------------------------------------------------------------
   194                          ;
   195                          ;  ARGUMENTS:
   196                          ;     none.
   197                          ;
   198                          ;  RETURNS:
   199                          ;     none.
   200                          ;
   201                          ;  SIDE EFFECTS:
   202                          ;    The A and X registers may be modified by this or future implementations
   203                          ;    of this function.  The same is true for all RAM page pointer registers in
   204                          ;    the Large Memory Model.  When necessary, it is the calling function's
   205                          ;    responsibility to perserve their values across calls to fastcall16 
   206                          ;    functions.
   207                          ;
   208  7315                     LTRX_DisableInt:
   209  7315                    _LTRX_DisableInt:
   210                             RAM_PROLOGUE RAM_USE_CLASS_1
   211  7315  41 E1 BF             M8C_DisableIntMask LTRX_TX_INT_REG, LTRX_TX_INT_MASK
   212  7318  41 E1 7F             M8C_DisableIntMask LTRX_RX_INT_REG, LTRX_RX_INT_MASK
   213                             RAM_EPILOGUE RAM_USE_CLASS_1
   214  731B  7F                   ret
   215                          .ENDSECTION
   216                          
   217                          
   218                          .SECTION
   219                          ;-----------------------------------------------------------------------------
   220                          ;  FUNCTION NAME: LTRX_SetTxIntMode(BYTE bTxIntMode)
   221                          ;
   222                          ;  DESCRIPTION:
   223                          ;     Sets the Tx Interrupt Mode bit in the Function Register.
   224                          ;-----------------------------------------------------------------------------
   225                          ;
   226                          ;  ARGUMENTS:
   227                          ;     BYTE bTxIntMode - The TX Interrupt mode setting. Use defined masks.
   228                          ;        Passed in the A register
   229                          ;
   230                          ;  RETURNS:
   231                          ;     none.
   232                          ;
   233                          ;  SIDE EFFECTS:
   234                          ;    The A and X registers may be modified by this or future implementations
   235                          ;    of this function.  The same is true for all RAM page pointer registers in
   236                          ;    the Large Memory Model.  When necessary, it is the calling function's
   237                          ;    responsibility to perserve their values across calls to fastcall16 
   238                          ;    functions.
   239                          ;
   240                          ;  THEORY of OPERATION OR PROCEDURE:
   241                          ;     Sets the TX interrupt mode bit to define whether the interrupt occurs
   242                          ;     on TX register empty or TX transmit complete
   243                          ;
   244  731C                     LTRX_SetTxIntMode:
   245  731C                    _LTRX_SetTxIntMode:
   246                             RAM_PROLOGUE RAM_USE_CLASS_1
   247  731C  71 10                M8C_SetBank1
   248  731E  21 01                and   A, LTRX_INT_MODE_TX_COMPLETE
   249  7320  A007                 jz    .SetModeRegEmpty
   250  7322  43 38 10             or    REG[LTRX_TX_FUNC_REG], bfFUNCTION_REG_TX_INT_MODE_BIT
   251  7325  70 EF                M8C_SetBank0
   252                             RAM_EPILOGUE RAM_USE_CLASS_1
   253  7327  7F                   ret
   254                          
   255  7328                    .SetModeRegEmpty:
   256  7328  41 38 EF             and   REG[LTRX_TX_FUNC_REG], ~bfFUNCTION_REG_TX_INT_MODE_BIT
   257  732B  70 EF                M8C_SetBank0
   258                             RAM_EPILOGUE RAM_USE_CLASS_1
   259  732D  7F                   ret
   260                          .ENDSECTION
   261                          
   262                          
   263                          .SECTION
   264                          ;-----------------------------------------------------------------------------
   265                          ;  FUNCTION NAME: LTRX_Start(BYTE bParity)
   266                          ;
   267                          ;  DESCRIPTION:
   268                          ;     Sets the start bit and parity in the Control register of this user module.
   269                          ;-----------------------------------------------------------------------------
   270                          ;
   271                          ;  ARGUMENTS:
   272                          ;     BYTE bParity - parity setting for the Transmitter and receiver. Use defined masks.
   273                          ;        Passed in the A register.
   274                          ;
   275                          ;  RETURNS:
   276                          ;     none.
   277                          ;
   278                          ;  SIDE EFFECTS:
   279                          ;    The A and X registers may be modified by this or future implementations
   280                          ;    of this function.  The same is true for all RAM page pointer registers in
   281                          ;    the Large Memory Model.  When necessary, it is the calling function's
   282                          ;    responsibility to perserve their values across calls to fastcall16 
   283                          ;    functions.
   284                          ;
   285  732E                     LTRX_Start:
   286  732E                    _LTRX_Start:
   287                             RAM_PROLOGUE RAM_USE_CLASS_1
   288                             ; Note, Proxy Class 4 only if receive buffer used; otherwise Proxy Class 1.
   289                          
   290  732E  29 01                or    A, bfCONTROL_REG_START_BIT
   291  7330  60 3B                mov   REG[LTRX_TX_CONTROL_REG], A
   292  7332  60 3F                mov   REG[LTRX_RX_CONTROL_REG], A
   293                          IF ( LTRX_RXBUF_ENABLE )
   294  7334  9128                 call  _LTRX_CmdReset
   295                          ENDIF
   296                             RAM_EPILOGUE RAM_USE_CLASS_1
   297  7336  7F                   ret
   298                          .ENDSECTION
   299                          
   300                          
   301                          .SECTION
   302                          ;-----------------------------------------------------------------------------
   303                          ;  FUNCTION NAME: LTRX_Stop
   304                          ;
   305                          ;  DESCRIPTION:
   306                          ;     Disables UART operation.
   307                          ;-----------------------------------------------------------------------------
   308                          ;
   309                          ;  ARGUMENTS:
   310                          ;     none.
   311                          ;
   312                          ;  RETURNS:
   313                          ;     none.
   314                          ;
   315                          ;  SIDE EFFECTS:
   316                          ;    The A and X registers may be modified by this or future implementations
   317                          ;    of this function.  The same is true for all RAM page pointer registers in
   318                          ;    the Large Memory Model.  When necessary, it is the calling function's
   319                          ;    responsibility to perserve their values across calls to fastcall16 
   320                          ;    functions.
   321                          ;
   322  7337                     LTRX_Stop:
   323  7337                    _LTRX_Stop:
   324                             RAM_PROLOGUE RAM_USE_CLASS_1
   325  7337  41 3B FE             and   REG[LTRX_TX_CONTROL_REG], ~bfCONTROL_REG_START_BIT
   326  733A  41 3F FE             and   REG[LTRX_RX_CONTROL_REG], ~bfCONTROL_REG_START_BIT
   327                             RAM_EPILOGUE RAM_USE_CLASS_1
   328  733D  7F                   ret
   329                          .ENDSECTION
   330                          
   331                          
   332                          .SECTION
   333                          ;-----------------------------------------------------------------------------
   334                          ;  FUNCTION NAME: LTRX_SendData
   335                          ;
   336                          ;  DESCRIPTION:
   337                          ;     Initiates a transmission of data.
   338                          ;-----------------------------------------------------------------------------
   339                          ;
   340                          ;  ARGUMENTS:
   341                          ;     BYTE  TxData - data to transmit. PASSED in A register.
   342                          ;
   343                          ;  RETURNS:
   344                          ;     none.
   345                          ;
   346                          ;  SIDE EFFECTS:
   347                          ;    The A and X registers may be modified by this or future implementations
   348                          ;    of this function.  The same is true for all RAM page pointer registers in
   349                          ;    the Large Memory Model.  When necessary, it is the calling function's
   350                          ;    responsibility to perserve their values across calls to fastcall16 
   351                          ;    functions.
   352                          ;
   353  733E                     LTRX_SendData:
   354  733E                    _LTRX_SendData:
   355                             RAM_PROLOGUE RAM_USE_CLASS_1
   356  733E  60 39                mov REG[LTRX_TX_BUFFER_REG], A
   357                             RAM_EPILOGUE RAM_USE_CLASS_1
   358  7340  7F                   ret
   359                          .ENDSECTION
   360                          
   361                          
   362                          .SECTION
   363                          ;-----------------------------------------------------------------------------
   364                          ;  FUNCTION NAME: LTRX_bReadTxStatus
   365                          ;
   366                          ;  DESCRIPTION:
   367                          ;     Reads the Tx Status bits in the Control/Status register.
   368                          ;-----------------------------------------------------------------------------
   369                          ;
   370                          ;  ARGUMENTS:
   371                          ;     none.
   372                          ;
   373                          ;  RETURNS:
   374                          ;     BYTE  bTxStatus - transmit status data.  Use defined masks for detecting
   375                          ;           status bits (returned in A)
   376                          ;
   377                          ;  SIDE EFFECTS:
   378                          ;    The A and X registers may be modified by this or future implementations
   379                          ;    of this function.  The same is true for all RAM page pointer registers in
   380                          ;    the Large Memory Model.  When necessary, it is the calling function's
   381                          ;    responsibility to perserve their values across calls to fastcall16 
   382                          ;    functions.
   383                          ;
   384  7341                     LTRX_bReadTxStatus:
   385  7341                    _LTRX_bReadTxStatus:
   386  7341                     bLTRX_ReadTxStatus:                             ; For backwards compatibility only
   387  7341                    _bLTRX_ReadTxStatus:                             ; For backwards compatibility only
   388                             RAM_PROLOGUE RAM_USE_CLASS_1
   389  7341  5D 3B                mov A,  REG[LTRX_TX_CONTROL_REG]
   390                             RAM_EPILOGUE RAM_USE_CLASS_1
   391  7343  7F                   ret
   392                          .ENDSECTION
   393                          
   394                          
   395                          .SECTION
   396                          ;-----------------------------------------------------------------------------
   397                          ;  FUNCTION NAME: LTRX_bReadRxData
   398                          ;
   399                          ;  DESCRIPTION:
   400                          ;     Reads the RX buffer register.  Should check the status regiser to make
   401                          ;     sure data is valid.
   402                          ;-----------------------------------------------------------------------------
   403                          ;
   404                          ;  ARGUMENTS:
   405                          ;     none.
   406                          ;
   407                          ;  RETURNS:
   408                          ;     bRxData - returned in A.
   409                          ;
   410                          ;  SIDE EFFECTS:
   411                          ;    The A and X registers may be modified by this or future implementations
   412                          ;    of this function.  The same is true for all RAM page pointer registers in
   413                          ;    the Large Memory Model.  When necessary, it is the calling function's
   414                          ;    responsibility to perserve their values across calls to fastcall16 
   415                          ;    functions.
   416                          ;
   417  7344                     LTRX_bReadRxData:
   418  7344                    _LTRX_bReadRxData:
   419  7344                     bLTRX_ReadRxData:                               ; For backwards compatibility only
   420  7344                    _bLTRX_ReadRxData:                               ; For backwards compatibility only
   421                             RAM_PROLOGUE RAM_USE_CLASS_1
   422  7344  5D 3E                mov A, REG[LTRX_RX_BUFFER_REG]
   423                             RAM_EPILOGUE RAM_USE_CLASS_1
   424  7346  7F                   ret
   425                          .ENDSECTION
   426                          
   427                          
   428                          .SECTION
   429                          ;-----------------------------------------------------------------------------
   430                          ;  FUNCTION NAME: LTRX_bReadRxStatus
   431                          ;
   432                          ;  DESCRIPTION:
   433                          ;     Reads the RX Status bits in the Control/Status register.
   434                          ;-----------------------------------------------------------------------------
   435                          ;
   436                          ;  ARGUMENTS:
   437                          ;     none.
   438                          ;
   439                          ;  RETURNS:
   440                          ;     BYTE  bRXStatus - receive status data.  Use the following defined bits
   441                          ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
   442                          ;           returned in A.
   443                          ;
   444                          ;  SIDE EFFECTS:
   445                          ;    The A and X registers may be modified by this or future implementations
   446                          ;    of this function.  The same is true for all RAM page pointer registers in
   447                          ;    the Large Memory Model.  When necessary, it is the calling function's
   448                          ;    responsibility to perserve their values across calls to fastcall16 
   449                          ;    functions.
   450                          ;
   451  7347                     LTRX_bReadRxStatus:
   452  7347                    _LTRX_bReadRxStatus:
   453  7347                     bLTRX_ReadRxStatus:                             ; For backwards compatibility only
   454  7347                    _bLTRX_ReadRxStatus:                             ; For backwards compatibility only
   455                             RAM_PROLOGUE RAM_USE_CLASS_1
   456  7347  5D 3F                mov A,  REG[LTRX_RX_CONTROL_REG]
   457                             RAM_EPILOGUE RAM_USE_CLASS_1
   458  7349  7F                   ret
   459                          .ENDSECTION
   460                          
   461                          
   462                          .SECTION
   463                          ;-----------------------------------------------------------------------------
   464                          ;  FUNCTION NAME: LTRX_TxIntMode
   465                          ;
   466                          ;  DESCRIPTION:
   467                          ;     This function is used to change the TX Interrupt mode.
   468                          ;-----------------------------------------------------------------------------
   469                          ;
   470                          ;  ARGUMENTS:
   471                          ;     A => Tx Interrupt mode
   472                          ;             0 => Interrupt on TX_Reg_Empty  (Default)
   473                          ;             1 => Interrupt on TX Complete
   474                          ;
   475                          ;  RETURNS:
   476                          ;     none.
   477                          ;
   478                          ;  SIDE EFFECTS:
   479                          ;    The A and X registers may be modified by this or future implementations
   480                          ;    of this function.  The same is true for all RAM page pointer registers in
   481                          ;    the Large Memory Model.  When necessary, it is the calling function's
   482                          ;    responsibility to perserve their values across calls to fastcall16 
   483                          ;    functions.
   484                          ;
   485  734A                     LTRX_TxIntMode:
   486  734A                    _LTRX_TxIntMode:
   487                             RAM_PROLOGUE RAM_USE_CLASS_1
   488                          
   489  734A  21 01                and  A,LTRX_INT_MODE_TX_COMPLETE
   490  734C  71 10                M8C_SetBank1
   491  734E  39 01                cmp  A,LTRX_INT_MODE_TX_COMPLETE
   492  7350  A006                 jz   .SetTxCmpMode
   493                          
   494  7352  41 38 EF             and  reg[LTRX_TX_FUNC_REG],0xEF               ; Set Interrupt on Tx_Reg_Empty
   495  7355  8004                 jmp  .TxIntMode_End
   496                          
   497  7357                    .SetTxCmpMode:                                       ; Set Interrupt on TX Complete
   498  7357  43 38 10             or   reg[LTRX_TX_FUNC_REG],0x10
   499                          
   500  735A                    .TxIntMode_End:
   501  735A  70 EF                M8C_SetBank0
   502                             RAM_EPILOGUE RAM_USE_CLASS_1
   503  735C  7F                   ret
   504                          .ENDSECTION
   505                          
   506                              
   507                          .SECTION
   508                          ;-----------------------------------------------------------------------------
   509                          ;  FUNCTION NAME: LTRX_IntCntl
   510                          ;
   511                          ;  DESCRIPTION:
   512                          ;     This function is used to enable/disable the Rx and Tx interrupt.
   513                          ;-----------------------------------------------------------------------------
   514                          ;
   515                          ;  ARGUMENTS:
   516                          ;     A => Interrupt mask
   517                          ;
   518                          ;  RETURNS:
   519                          ;     none.
   520                          ;
   521                          ;  SIDE EFFECTS:
   522                          ;    The A and X registers may be modified by this or future implementations
   523                          ;    of this function.  The same is true for all RAM page pointer registers in
   524                          ;    the Large Memory Model.  When necessary, it is the calling function's
   525                          ;    responsibility to perserve their values across calls to fastcall16 
   526                          ;    functions.
   527                          ;
   528                          ;  THEORY of OPERATION or PROCEDURE:
   529                          ;     Set or Clears the Tx/Rx user module interrupt enable mask bit in the TX
   530                          ;     and RX block.
   531                          ;
   532  735D                     LTRX_IntCntl:
   533  735D                    _LTRX_IntCntl:
   534                             RAM_PROLOGUE RAM_USE_CLASS_1
   535                          
   536  735D  08                   push A
   537  735E  21 01                and  A,LTRX_ENABLE_RX_INT
   538  7360  A006                 jz   .DisRxInt
   539                               ; Enable Rx Interrupt
   540  7362  43 E1 80             M8C_EnableIntMask LTRX_RX_INT_REG, LTRX_RX_INT_MASK
   541  7365  8004                 jmp  .CheckTxInt
   542  7367                    .DisRxInt:
   543                               ; Disable Rx Interrupt
   544  7367  41 E1 7F             M8C_DisableIntMask LTRX_RX_INT_REG, LTRX_RX_INT_MASK
   545                          
   546  736A                    .CheckTxInt:
   547  736A  18                   pop  A
   548  736B  21 02                and  A,LTRX_ENABLE_TX_INT
   549  736D  A006                 jz   .DisTxInt
   550                               ; Enable Tx Interrupt
   551  736F  43 E1 40             M8C_EnableIntMask LTRX_TX_INT_REG, LTRX_TX_INT_MASK
   552  7372  8004                 jmp  .End_IntCntl
   553  7374                    .DisTxInt:
   554                               ; Disable Tx Interrupt
   555  7374  41 E1 BF             M8C_DisableIntMask LTRX_TX_INT_REG, LTRX_TX_INT_MASK
   556                          
   557  7377                    .End_IntCntl:
   558                             RAM_EPILOGUE RAM_USE_CLASS_1
   559  7377  7F                   ret
   560                          .ENDSECTION
   561                          
   562                          
   563                          ;=============================================================================
   564                          ;=============================================================================
   565                          ;
   566                          ;     High-Level Commands
   567                          ;
   568                          ;=============================================================================
   569                          ;=============================================================================
   570                          
   571                          
   572                          ;-----------------------------------------------------------------------------
   573                          ;  FUNCTION NAME: LTRX_PutSHexByte
   574                          ;
   575                          ;  DESCRIPTION:
   576                          ;     Print a byte in Hex (two characters) to the UART Tx
   577                          ;-----------------------------------------------------------------------------
   578                          ;
   579                          ;  ARGUMENTS:
   580                          ;     A  => (BYTE) Data/char to be printed
   581                          ;
   582                          ;  RETURNS:
   583                          ;     none.
   584                          ;
   585                          ;  SIDE EFFECTS:
   586                          ;    The A and X registers may be modified by this or future implementations
   587                          ;    of this function.  The same is true for all RAM page pointer registers in
   588                          ;    the Large Memory Model.  When necessary, it is the calling function's
   589                          ;    responsibility to perserve their values across calls to fastcall16 
   590                          ;    functions.
   591                          ;
   592                          .LITERAL
   593  7378                    LTRX_HEX_STR:
   594  7378  30 31 32 33 34 35      DS    "0123456789ABCDEF"
              36 37 38 39 41 42 
              43 44 45 46       
   595                          .ENDLITERAL
   596                          
   597                          .SECTION
   598  7388                     LTRX_PutSHexByte:
   599  7388                    _LTRX_PutSHexByte:
   600                             RAM_PROLOGUE RAM_USE_CLASS_1
   601  7388  08                   push  A                             ; Save lower nibble
   602  7389  67                   asr   A                             ; Shift high nibble to right
   603  738A  67                   asr   A
   604  738B  67                   asr   A
   605  738C  67                   asr   A
   606  738D  21 0F                and   A,0Fh                         ; Mask off nibble
   607  738F  FFE7                 index LTRX_HEX_STR                  ; Get Hex value
   608  7391  900F                 call  LTRX_PutChar                  ; Write data to screen
   609  7393  18                   pop   A                             ; Restore value
   610  7394  21 0F                and   A,0Fh                         ; Mask off lower nibble
   611  7396  FFE0                 index LTRX_HEX_STR                  ; Get Hex value
   612  7398  9008                 call  LTRX_PutChar                  ; Write data to screen
   613                             RAM_EPILOGUE RAM_USE_CLASS_1
   614  739A  7F                   ret
   615                          .ENDSECTION
   616                          
   617                          
   618                          .SECTION
   619                          ;-----------------------------------------------------------------------------
   620                          ;  FUNCTION NAME: LTRX_PutSHexInt
   621                          ;
   622                          ;  DESCRIPTION:
   623                          ;     Print an Int in Hex (four characters) to UART Tx
   624                          ;-----------------------------------------------------------------------------
   625                          ;
   626                          ;  ARGUMENTS:
   627                          ;     Pointer to string
   628                          ;     A  => ASB of Int
   629                          ;     X  => MSB of Int
   630                          ;
   631                          ;  RETURNS:
   632                          ;     none.
   633                          ;
   634                          ;  SIDE EFFECTS:
   635                          ;    The A and X registers may be modified by this or future implementations
   636                          ;    of this function.  The same is true for all RAM page pointer registers in
   637                          ;    the Large Memory Model.  When necessary, it is the calling function's
   638                          ;    responsibility to perserve their values across calls to fastcall16 
   639                          ;    functions.
   640                          ;
   641                          
   642  739B                     LTRX_PutSHexInt:
   643  739B                    _LTRX_PutSHexInt:
   644                             RAM_PROLOGUE RAM_USE_CLASS_1
   645  739B  4B                   swap  A,X
   646  739C  9FEA                 call  LTRX_PutSHexByte              ; Print MSB
   647  739E  5B                   mov   A,X                           ; Move LSB into position
   648  739F  9FE7                 call  LTRX_PutSHexByte              ; Print LSB
   649                             RAM_EPILOGUE RAM_USE_CLASS_1
   650  73A1  7F                   ret
   651                          .ENDSECTION
   652                          
   653                          
   654                          .SECTION
   655                          ;-----------------------------------------------------------------------------
   656                          ;  FUNCTION NAME: LTRX_PutChar
   657                          ;
   658                          ;  DESCRIPTION:
   659                          ;     Send character out through UART TX port.
   660                          ;-----------------------------------------------------------------------------
   661                          ;
   662                          ;  ARGUMENTS:
   663                          ;     A has Character to send to UART Tx Port
   664                          ;
   665                          ;  RETURNS:
   666                          ;     none
   667                          ;
   668                          ;  SIDE EFFECTS:
   669                          ;    The A and X registers may be modified by this or future implementations
   670                          ;    of this function.  The same is true for all RAM page pointer registers in
   671                          ;    the Large Memory Model.  When necessary, it is the calling function's
   672                          ;    responsibility to perserve their values across calls to fastcall16 
   673                          ;    functions.
   674                          ;
   675                          
   676                             macro InLinePutChar( Source )
   677                          .BufEmptyWaitLoop:
   678                             tst REG[LTRX_TX_CONTROL_REG], LTRX_TX_BUFFER_EMPTY     ; Check Tx Status
   679                             jz  .BufEmptyWaitLoop
   680                             mov REG[LTRX_TX_BUFFER_REG], @Source          ; Write data to Tx Port
   681  73A2                       endm
   682                          
   683  73A2                     LTRX_PutChar:
   684  73A2                    _LTRX_PutChar:
   685                             RAM_PROLOGUE RAM_USE_CLASS_1
   686  73A2                       InLinePutChar A
   687                             RAM_EPILOGUE RAM_USE_CLASS_1
   688  73A9  7F                   ret
   689                          .ENDSECTION
   690                          
   691                          
   692                          .SECTION
   693                          ;-----------------------------------------------------------------------------
   694                          ;  FUNCTION NAME: LTRX_cGetChar
   695                          ;
   696                          ;  DESCRIPTION:
   697                          ;     Read character from UART RX port.
   698                          ;-----------------------------------------------------------------------------
   699                          ;
   700                          ;  ARGUMENTS:
   701                          ;      none
   702                          ;
   703                          ;  RETURNS:
   704                          ;     char that is returned from UART
   705                          ;
   706                          ;  SIDE EFFECTS:
   707                          ;    The A and X registers may be modified by this or future implementations
   708                          ;    of this function.  The same is true for all RAM page pointer registers in
   709                          ;    the Large Memory Model.  When necessary, it is the calling function's
   710                          ;    responsibility to perserve their values across calls to fastcall16 
   711                          ;    functions.
   712                          ;
   713                          ;    Program flow will stay in this function until a character is received.
   714                          ;    If the watchdog timer is used, care must be taken to make sure that
   715                          ;    the delay between characters is less than the watchdog timeout.
   716                          ;
   717  73AA                     LTRX_cGetChar:
   718  73AA                    _LTRX_cGetChar:
   719                             RAM_PROLOGUE RAM_USE_CLASS_1
   720  73AA  49 3F 08             tst REG[LTRX_RX_CONTROL_REG],LTRX_RX_REG_FULL    ; Check if a character is ready
   721  73AD  AFFC                 jz  LTRX_cGetChar                             ; If not loop
   722  73AF  5D 3E                mov A, REG[LTRX_RX_BUFFER_REG]                ; Get character
   723                             RAM_EPILOGUE RAM_USE_CLASS_1
   724  73B1  7F                   ret
   725                          .ENDSECTION
   726                          
   727                          
   728                          .SECTION
   729                          ;-----------------------------------------------------------------------------
   730                          ;  FUNCTION NAME: LTRX_cReadChar
   731                          ;
   732                          ;  DESCRIPTION:
   733                          ;     Read character from UART RX port.
   734                          ;-----------------------------------------------------------------------------
   735                          ;
   736                          ;  ARGUMENTS:
   737                          ;      none
   738                          ;
   739                          ;  RETURNS:
   740                          ;     char that is returned from UART
   741                          ;
   742                          ;  SIDE EFFECTS:
   743                          ;    The A and X registers may be modified by this or future implementations
   744                          ;    of this function.  The same is true for all RAM page pointer registers in
   745                          ;    the Large Memory Model.  When necessary, it is the calling function's
   746                          ;    responsibility to perserve their values across calls to fastcall16 
   747                          ;    functions.
   748                          ;
   749                          ;    A valid 0x00 character will be ignored, since a 0x00 return value
   750                          ;    implies a valid character or an error condition occured.
   751                          ;
   752  73B2                     LTRX_cReadChar:
   753  73B2                    _LTRX_cReadChar:
   754                             RAM_PROLOGUE RAM_USE_CLASS_1
   755  73B2  5D 3F                mov  A,REG[LTRX_RX_CONTROL_REG]                         ; Get Status of RX
   756  73B4  08                   push A
   757  73B5  21 08                and  A,LTRX_RX_COMPLETE                                 ; Check if a character is ready
   758  73B7  B004                 jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
   759  73B9  18                   pop  A
   760  73BA  800B                 jmp  .RX_NO_VALID_CHAR
   761                          
   762  73BC                    .RX_DATA_RDY:
   763  73BC  5D 3E                mov  A,REG[LTRX_RX_BUFFER_REG ]          
   764  73BE  4B                   swap A,X                                                ; determine if data is valid
   765                          
   766  73BF  18                   pop  A                                                  ; Check for errors
   767  73C0  21 A0                and  A,(LTRX_RX_PARITY_ERROR | LTRX_RX_FRAMING_ERROR)
   768  73C2  B003                 jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
   769  73C4  4B                   swap A,X                                                ; Put data in A and exit
   770                             RAM_EPILOGUE RAM_USE_CLASS_1
   771  73C5  7F                   ret
   772                          
   773  73C6                    .RX_NO_VALID_CHAR:
   774  73C6  50 00                mov A,0x00                                              ; Zero out character
   775                          
   776  73C8                     End_LTRX_cReadChar:
   777                             RAM_EPILOGUE RAM_USE_CLASS_1
   778  73C8  7F                   ret
   779                          .ENDSECTION
   780                          
   781                          
   782                          .SECTION
   783                          ;-----------------------------------------------------------------------------
   784                          ;  FUNCTION NAME: LTRX_iReadChar
   785                          ;
   786                          ;  WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
   787                          ;  to just set a value in the upper byte if error conditions exists.
   788                          ;
   789                          ;  DESCRIPTION:
   790                          ;     Read character from UART RX port.
   791                          ;-----------------------------------------------------------------------------
   792                          ;
   793                          ;  ARGUMENTS:
   794                          ;      none
   795                          ;
   796                          ;  RETURNS:
   797                          ;     An integer value is returned.  A negative value inplies and error
   798                          ;     condition, a positive value between 0 and 255 is the return character.
   799                          ;
   800                          ;     Error Codes:
   801                          ;        0x80CC    Parity Error
   802                          ;        0x40CC    Overrun Error
   803                          ;        0x20CC    Framing Error
   804                          ;        0x01CC    No Data available
   805                          ;
   806                          ;  SIDE EFFECTS:
   807                          ;    The A and X registers may be modified by this or future implementations
   808                          ;    of this function.  The same is true for all RAM page pointer registers in
   809                          ;    the Large Memory Model.  When necessary, it is the calling function's
   810                          ;    responsibility to perserve their values across calls to fastcall16 
   811                          ;    functions.
   812                          ;
   813  73C9                     LTRX_iReadChar:
   814  73C9                    _LTRX_iReadChar:
   815                             RAM_PROLOGUE RAM_USE_CLASS_1
   816  73C9  5D 3F                mov  A,REG[LTRX_RX_CONTROL_REG]                         ; Get Status of RX
   817                                                                                     ; Mask only errors and data ready
   818  73CB  21 E8                and  A,(LTRX_RX_ERROR|LTRX_RX_REG_FULL)
   819  73CD  08                   push A
   820  73CE  21 08                and  A,LTRX_RX_COMPLETE                                 ; Check if a character is ready
   821  73D0  B007                 jnz  .RX_GET_DATA                                       ; Data Ready go read it.
   822  73D2  18                   pop  A
   823  73D3  29 01                or   A,LTRX_RX_NO_DATA                                  ; Add no data flag
   824  73D5  4B                   swap A,X
   825  73D6  8007                 jmp  End_LTRX_iReadChar
   826                          
   827  73D8                    .RX_GET_DATA:
   828  73D8  18                   pop  A
   829  73D9  21 E0                and  A,LTRX_RX_ERROR
   830  73DB  4B                   swap A,X
   831  73DC  5D 3E                mov  A,REG[LTRX_RX_BUFFER_REG ]                         ; Read data first, then
   832                                                                                     ; determine if data is valid
   833                          
   834  73DE                     End_LTRX_iReadChar:
   835                             RAM_EPILOGUE RAM_USE_CLASS_1
   836  73DE  7F                   ret
   837                          .ENDSECTION
   838                          
   839                          
   840                          .SECTION
   841                          ;-----------------------------------------------------------------------------
   842                          ;  FUNCTION NAME: LTRX_PutString
   843                          ;
   844                          ;  DESCRIPTION:
   845                          ;     Send String out through UART TX port.
   846                          ;-----------------------------------------------------------------------------
   847                          ;
   848                          ;  ARGUMENTS:
   849                          ;     Pointer to String
   850                          ;     A has MSB of string address
   851                          ;     X has LSB of string address
   852                          ;
   853                          ;  RETURNS:
   854                          ;     none
   855                          ;
   856                          ;  SIDE EFFECTS:
   857                          ;    The A and X registers may be modified by this or future implementations
   858                          ;    of this function.  The same is true for all RAM page pointer registers in
   859                          ;    the Large Memory Model.  When necessary, it is the calling function's
   860                          ;    responsibility to perserve their values across calls to fastcall16 
   861                          ;    functions.
   862                          ;          
   863                          ;    Currently only the page pointer registers listed below are modified: 
   864                          ;          IDX_PP
   865                          ;
   866  73DF                     LTRX_PutString:
   867  73DF                    _LTRX_PutString:
   868                             RAM_PROLOGUE RAM_USE_CLASS_3
   869  73DF  60 D3                RAM_SETPAGE_IDX A
   870  73E1                    .PutStringLoop:
   871  73E1  52 00                mov   A,[X]                                   ; Get value pointed to by X
   872  73E3  A006                 jz    End_PutString                           ; Check for end of string
   873  73E5  9FBB                 call  LTRX_PutChar                            ; Send character to Tx port
   874  73E7  75                   inc   X                                       ; Advance pointer to next character
   875  73E8  8FF8                 jmp   .PutStringLoop                          ; Get next character
   876                          
   877  73EA                    End_PutString:
   878  73EA  70 3F                RAM_EPILOGUE RAM_USE_CLASS_3
   879  73EE  7F                   ret
   880                          .ENDSECTION
   881                              
   882                          .SECTION
   883                          ;-----------------------------------------------------------------------------
   884                          ;  FUNCTION NAME: LTRX_Write
   885                          ;
   886                          ;  DESCRIPTION:
   887                          ;     Send String of length X to serial port
   888                          ;-----------------------------------------------------------------------------
   889                          ;
   890                          ;  ARGUMENTS:
   891                          ;     Pointer to String
   892                          ;     [SP-5] Count of characters to send
   893                          ;     [SP-4] has MSB of string address
   894                          ;     [SP-3] has LSB of string address
   895                          ;
   896                          ;  RETURNS:
   897                          ;     none
   898                          ;
   899                          ;  SIDE EFFECTS:
   900                          ;    The A and X registers may be modified by this or future implementations
   901                          ;    of this function.  The same is true for all RAM page pointer registers in
   902                          ;    the Large Memory Model.  When necessary, it is the calling function's
   903                          ;    responsibility to perserve their values across calls to fastcall16 
   904                          ;    functions.
   905                          ;          
   906                          ;    Currently only the page pointer registers listed below are modified: 
   907                          ;          IDX_PP
   908                          ;
   909  FFFFFFFB                    CNT_LEN:    equ -5                               ; Length of data to send
   910  FFFFFFFC                    STR_MSB:    equ -4                               ; MSB pointer of string 
   911  FFFFFFFD                    STR_LSB:    equ -3                               ; LSB pointer of string 
   912                          
   913  73EF                     LTRX_Write:
   914  73EF                    _LTRX_Write:
   915                             RAM_PROLOGUE RAM_USE_CLASS_3
   916  73EF  62 D3 07             RAM_SETPAGE_IDX2STK                           ; Refer indexed addrs to the stack
   917  73F2  4F                   mov   X, SP                                   ; Establish the frame pointer 
   918                          
   919  73F3                    .NextByteLoop:
   920  73F3  52 FB                mov   A, [X+CNT_LEN]                          ; End of the string?
   921  73F5  A01A                 jz    .End_Write                              ;   Yes, prepare to exit
   922  73F7  7B FB                dec   [X+CNT_LEN]                             ; Decrement counter
   923                          
   924                             IF SYSTEM_LARGE_MEMORY_MODEL
   925  73F9  52 FC                mov   A, [X+STR_MSB]                          ; Load pointer to char to send
   926                             ENDIF
   927                          
   928  73FB  59 FD                mov   X, [X+STR_LSB]                          ; Load pointer to char to send
   929  73FD  60 D3                RAM_SETPAGE_IDX A                             ; switch index pages
   930  73FF  52 00                mov   A, [X]                                  ; Grab the data
   931  7401                       InLinePutChar A                               ; Put data in empty TX buf reg
   932  7408  4F                   mov   X, SP                                   ; Recover frame pointer
   933  7409  62 D3 07             RAM_SETPAGE_IDX2STK                           ; Prepare for stack access
   934  740C  77 FD                inc   [X+STR_LSB]                             ; Point to next byte, but do not
   935  740E  8FE4                 jmp   .NextByteLoop                           ;    cross RAM page boundary!
   936                          
   937  7410                    .End_Write:
   938  7410  70 3F                RAM_EPILOGUE RAM_USE_CLASS_3
   939  7414  7F                   ret
   940                          .ENDSECTION
   941                              
   942                          
   943                          .SECTION
   944                          ;-----------------------------------------------------------------------------
   945                          ;  FUNCTION NAME: LTRX_CWrite
   946                          ;
   947                          ;             WARNING WARNING NOT COMPLETE
   948                          ;
   949                          ;  DESCRIPTION:
   950                          ;     Send String of length X to serial port
   951                          ;-----------------------------------------------------------------------------
   952                          ;
   953                          ;  ARGUMENTS:
   954                          ;     [SP-4] MSB of Count of character to send
   955                          ;     [SP-3] LSB of Count of character to send
   956                          ;     [SP-2] has MSB of string address
   957                          ;     [SP-1] has LSB of string address
   958                          ;
   959                          ;  RETURNS:
   960                          ;     none
   961                          ;
   962                          ;  SIDE EFFECTS:
   963                          ;    The A and X registers may be modified by this or future implementations
   964                          ;    of this function.  The same is true for all RAM page pointer registers in
   965                          ;    the Large Memory Model.  When necessary, it is the calling function's
   966                          ;    responsibility to perserve their values across calls to fastcall16 
   967                          ;    functions.
   968                          ;
   969  FFFFFFFA                    CLEN_MSB:   equ -6           ; MSB Length of data to send
   970  FFFFFFFB                    CLEN_LSB:   equ -5           ; LSB Length of data to send
   971  FFFFFFFC                    CSTR_MSB:   equ -4           ; MSB pointer of string
   972  FFFFFFFD                    CSTR_LSB:   equ -3           ; LSB pointer of string
   973                          
   974  7415                     LTRX_CWrite:
   975  7415                    _LTRX_CWrite:
   976  7415  71 40                RAM_PROLOGUE RAM_USE_CLASS_2
   977  7417  4F                   mov   X,SP
   978  7418                    .CW_Loop:
   979  7418  3D FA 00             cmp   [X+CLEN_MSB],0x00                  ; Check for zero counter
   980  741B  B006                 jnz   .CW_WRITEIT
   981  741D  3D FB 00             cmp   [X+CLEN_LSB],0x00
   982  7420  A01D                 jz    .End_CWrite                        ; Leave if done
   983                          
   984  7422                    .CW_WRITEIT:                                
   985  7422  10                   push  X                                  ; Save frame pointer
   986  7423  52 FC                mov   A,[X+CSTR_MSB]
   987  7425  59 FD                mov   X,[X+CSTR_LSB]
   988  7427  28                   romx                                     ; Get character from ROM
   989  7428                       InLinePutChar A                          ; Put data in empty TX buf reg
   990  742F  20                   pop   X                                  ; Restore frame pointer
   991  7430  07 FD 01             add   [X+CSTR_LSB],1                     ; Increment the string pointer
   992  7433  0F FC 00             adc   [X+CSTR_MSB],0
   993  7436  17 FB 01             sub   [X+CLEN_LSB],0x01                  ; Dec the counter
   994  7439  1F FA 00             sbb   [X+CLEN_MSB],0x00
   995  743C  8FDB                 jmp   .CW_Loop
   996                          
   997  743E                    .End_CWrite:
   998  743E  70 3F                RAM_EPILOGUE RAM_USE_CLASS_2
   999  7442  7F                   ret
  1000                          .ENDSECTION
  1001                          
  1002                          
  1003                          .SECTION
  1004                          ;-----------------------------------------------------------------------------
  1005                          ;  FUNCTION NAME: LTRX_CPutString
  1006                          ;
  1007                          ;  DESCRIPTION:
  1008                          ;     Send String out through UART TX port.
  1009                          ;-----------------------------------------------------------------------------
  1010                          ;
  1011                          ;  ARGUMENTS:
  1012                          ;     Pointer to String
  1013                          ;     A has MSB of string address
  1014                          ;     X has LSB of string address
  1015                          ;
  1016                          ;  RETURNS:
  1017                          ;     none
  1018                          ;
  1019                          ;  SIDE EFFECTS:
  1020                          ;    The A and X registers may be modified by this or future implementations
  1021                          ;    of this function.  The same is true for all RAM page pointer registers in
  1022                          ;    the Large Memory Model.  When necessary, it is the calling function's
  1023                          ;    responsibility to perserve their values across calls to fastcall16 
  1024                          ;    functions.
  1025                          ;
  1026  7443                     LTRX_CPutString:
  1027  7443                    _LTRX_CPutString:
  1028                             RAM_PROLOGUE RAM_USE_CLASS_1
  1029  7443  08                   push  A                                       ; Store ROM pointer
  1030  7444  10                   push  X
  1031  7445  28                   romx                                          ; Get character from ROM
  1032  7446  A00B                 jz    .End_CPutString
  1033  7448  9F58                 call  LTRX_PutChar                            ; Print character
  1034  744A  20                   pop   X
  1035  744B  18                   pop   A
  1036  744C  75                   inc   X                                       ; Inc LSB of pointer
  1037  744D  DFF5                 jnc   LTRX_CPutString                         ; Check for carry
  1038  744F  74                   inc   A                                       ; Inc MSB of pointer
  1039  7450  8FF2                 jmp   LTRX_CPutString
  1040                          
  1041                          
  1042  7452                    .End_CPutString:
  1043  7452  38 FE                add   SP, -2
  1044                             RAM_EPILOGUE RAM_USE_CLASS_1
  1045  7454  7F                   ret
  1046                          .ENDSECTION
  1047                          
  1048                          
  1049                          .SECTION
  1050                          ;-----------------------------------------------------------------------------
  1051                          ;  FUNCTION NAME: LTRX_PutCRLF
  1052                          ;
  1053                          ;  DESCRIPTION:
  1054                          ;     Send a CR and LF
  1055                          ;-----------------------------------------------------------------------------
  1056                          ;
  1057                          ;  ARGUMENTS:
  1058                          ;     none.
  1059                          ;
  1060                          ;  RETURNS:
  1061                          ;     none.
  1062                          ;
  1063                          ;  SIDE EFFECTS:
  1064                          ;    The A and X registers may be modified by this or future implementations
  1065                          ;    of this function.  The same is true for all RAM page pointer registers in
  1066                          ;    the Large Memory Model.  When necessary, it is the calling function's
  1067                          ;    responsibility to perserve their values across calls to fastcall16 
  1068                          ;    functions.
  1069                          ;
  1070  7455                     LTRX_PutCRLF:
  1071  7455                    _LTRX_PutCRLF:
  1072                             RAM_PROLOGUE RAM_USE_CLASS_1
  1073  7455  50 0D                mov  A,0x0D                        ; Send CR
  1074  7457  9F49                 call LTRX_PutChar
  1075  7459  50 0A                mov  A,0x0A                        ; Send LF
  1076  745B  9F45                 call LTRX_PutChar
  1077                             RAM_EPILOGUE RAM_USE_CLASS_1
  1078  745D  7F                   ret
  1079                          .ENDSECTION
  1080                          
  1081                          
  1082                          IF (LTRX_RXBUF_ENABLE)
  1083                          ;=============================================================================
  1084                          ;=============================================================================
  1085                          ;
  1086                          ;     Command Buffer commands
  1087                          ;
  1088                          ;=============================================================================
  1089                          ;=============================================================================
  1090                          
  1091                          .SECTION
  1092                          ;-----------------------------------------------------------------------------
  1093                          ;  FUNCTION NAME: LTRX_CmdReset
  1094                          ;
  1095                          ;  DESCRIPTION:
  1096                          ;     Reset command string and status flags
  1097                          ;-----------------------------------------------------------------------------
  1098                          ;
  1099                          ;  ARGUMENTS:
  1100                          ;     none.
  1101                          ;
  1102                          ;  RETURNS:
  1103                          ;     none.
  1104                          ;
  1105                          ;  SIDE EFFECTS:
  1106                          ;    The A and X registers may be modified by this or future implementations
  1107                          ;    of this function.  The same is true for all RAM page pointer registers in
  1108                          ;    the Large Memory Model.  When necessary, it is the calling function's
  1109                          ;    responsibility to perserve their values across calls to fastcall16 
  1110                          ;    functions.
  1111                          ;          
  1112                          ;    Currently only the page pointer registers listed below are modified: 
  1113                          ;          CUR_PP
  1114                          ;
  1115                          ;  THEORY of OPERATION or PROCEDURE:
  1116                          ;     Clear the command buffer, command counter, and flag.
  1117                          ;
  1118  745E                     LTRX_CmdReset:
  1119  745E                    _LTRX_CmdReset:
  1120                             RAM_PROLOGUE RAM_USE_CLASS_4
  1121  745E  62 D0 00             RAM_SETPAGE_CUR >LTRX_aRxBuffer
  1122  7461  55 43  00            mov [LTRX_aRxBuffer], 0x00
  1123  7464  62 D0 00             RAM_SETPAGE_CUR >LTRX_bRxCnt
  1124  7467  55 41  00            mov [LTRX_bRxCnt], 0x00
  1125  746A  26 40  00            and [LTRX_fStatus], 0x00
  1126  746D  62 D0 00             RAM_SETPAGE_CUR >ptrParam
  1127  7470  55 5F  00            mov [ptrParam],0x00
  1128                             RAM_EPILOGUE RAM_USE_CLASS_4
  1129  7473  7F                   ret
  1130                          .ENDSECTION
  1131                          
  1132                          
  1133                          .SECTION
  1134                          ;-----------------------------------------------------------------------------
  1135                          ;  FUNCTION NAME: LTRX_bCmdCheck
  1136                          ;
  1137                          ;  DESCRIPTION:
  1138                          ;     Check to see if valid command in buffer.
  1139                          ;-----------------------------------------------------------------------------
  1140                          ;
  1141                          ;  ARGUMENTS:
  1142                          ;     none.
  1143                          ;
  1144                          ;  RETURNS:
  1145                          ;     BYTE  fStatus - Status of command receive buffer.
  1146                          ;                     Returns non-zero value in A if command is valid.
  1147                          ;
  1148                          ;  SIDE EFFECTS:
  1149                          ;    The A and X registers may be modified by this or future implementations
  1150                          ;    of this function.  The same is true for all RAM page pointer registers in
  1151                          ;    the Large Memory Model.  When necessary, it is the calling function's
  1152                          ;    responsibility to perserve their values across calls to fastcall16 
  1153                          ;    functions.
  1154                          ;          
  1155                          ;    Currently only the page pointer registers listed below are modified: 
  1156                          ;          CUR_PP
  1157                          ;
  1158                          ;  THEORY of OPERATION or PROCEDURE:
  1159                          ;     Read the status and control register.
  1160                          ;
  1161  7474                     LTRX_bCmdCheck:
  1162  7474                    _LTRX_bCmdCheck:
  1163                             RAM_PROLOGUE RAM_USE_CLASS_4
  1164  7474  62 D0 00             RAM_SETPAGE_CUR >LTRX_fStatus
  1165  7477  51 40                mov A,  [LTRX_fStatus]
  1166  7479  21 01                and A, LTRX_RX_BUF_CMDTERM                    ; Mask off Command status
  1167                             RAM_EPILOGUE RAM_USE_CLASS_4
  1168  747B  7F                   ret
  1169                          .ENDSECTION
  1170                              
  1171                          
  1172                          .SECTION
  1173                          ;-----------------------------------------------------------------------------
  1174                          ;  FUNCTION NAME: LTRX_bErrCheck
  1175                          ;
  1176                          ;  DESCRIPTION:
  1177                          ;     Check to see if an error has occured since last CmdReset
  1178                          ;-----------------------------------------------------------------------------
  1179                          ;
  1180                          ;  ARGUMENTS:
  1181                          ;     none.
  1182                          ;
  1183                          ;  RETURNS:
  1184                          ;     BYTE  fStatus - Status of command receive buffer.
  1185                          ;                     Returns non-zero value in A if command is valid.
  1186                          ;           0x80 => Parity Error
  1187                          ;           0x40 => OverRun Error
  1188                          ;           0x20 => Framing Error
  1189                          ;           0x10 => Software Buffer OverRun
  1190                          ;
  1191                          ;  SIDE EFFECTS:
  1192                          ;    The A and X registers may be modified by this or future implementations
  1193                          ;    of this function.  The same is true for all RAM page pointer registers in
  1194                          ;    the Large Memory Model.  When necessary, it is the calling function's
  1195                          ;    responsibility to perserve their values across calls to fastcall16 
  1196                          ;    functions.
  1197                          ;          
  1198                          ;    Currently only the page pointer registers listed below are modified: 
  1199                          ;          CUR_PP
  1200                          ;     Error Status is clear when read.
  1201                          ;
  1202                          ;  THEORY of OPERATION or PROCEDURE:
  1203                          ;     Read RX buffer error status and clear status
  1204                          ;
  1205  747C                     LTRX_bErrCheck:
  1206  747C                    _LTRX_bErrCheck:
  1207                             RAM_PROLOGUE RAM_USE_CLASS_4
  1208  747C  62 D0 00             RAM_SETPAGE_CUR >LTRX_fStatus
  1209  747F  51 40                mov A,  [LTRX_fStatus]
  1210  7481  21 F0                and A, LTRX_RX_BUF_ERROR                      ; Mask off Error status
  1211  7483  26 40  0F            and [LTRX_fStatus], ~LTRX_RX_BUF_ERROR
  1212                             RAM_EPILOGUE RAM_USE_CLASS_4
  1213  7486  7F                   ret
  1214                          .ENDSECTION
  1215                          
  1216                          .SECTION
  1217                          ;-----------------------------------------------------------------------------
  1218                          ;  FUNCTION NAME: LTRX_bCmdLength
  1219                          ;
  1220                          ;  DESCRIPTION:
  1221                          ;     Get length of command string
  1222                          ;-----------------------------------------------------------------------------
  1223                          ;
  1224                          ;  ARGUMENTS:
  1225                          ;     none.
  1226                          ;
  1227                          ;  RETURNS:
  1228                          ;     BYTE  bRxCnt    Returns the command length in A.
  1229                          ;
  1230                          ;  SIDE EFFECTS:
  1231                          ;    The A and X registers may be modified by this or future implementations
  1232                          ;    of this function.  The same is true for all RAM page pointer registers in
  1233                          ;    the Large Memory Model.  When necessary, it is the calling function's
  1234                          ;    responsibility to perserve their values across calls to fastcall16 
  1235                          ;    functions.
  1236                          ;          
  1237                          ;    Currently only the page pointer registers listed below are modified: 
  1238                          ;          CUR_PP
  1239                          ;
  1240  7487                     LTRX_bCmdLength:
  1241  7487                    _LTRX_bCmdLength:
  1242                             RAM_PROLOGUE RAM_USE_CLASS_4
  1243  7487  62 D0 00             RAM_SETPAGE_CUR >LTRX_bRxCnt
  1244  748A  51 41                mov A,  [LTRX_bRxCnt]
  1245                             RAM_EPILOGUE RAM_USE_CLASS_4
  1246  748C  7F                   ret
  1247                          .ENDSECTION
  1248                          
  1249                          
  1250                          .SECTION
  1251                          ;-----------------------------------------------------------------------------
  1252                          ;  FUNCTION NAME: LTRX_szGetParam
  1253                          ;
  1254                          ;  DESCRIPTION:
  1255                          ;      Return next parameter from LTRX Rx buffer
  1256                          ;-----------------------------------------------------------------------------
  1257                          ;
  1258                          ;  ARGUMENTS:  none
  1259                          ;
  1260                          ;  RETURNS:
  1261                          ;     A => MSB of parameter address
  1262                          ;     X => LSB of parameter address
  1263                          ;
  1264                          ;  SIDE EFFECTS:
  1265                          ;    The A and X registers may be modified by this or future implementations
  1266                          ;    of this function.  The same is true for all RAM page pointer registers in
  1267                          ;    the Large Memory Model.  When necessary, it is the calling function's
  1268                          ;    responsibility to perserve their values across calls to fastcall16 
  1269                          ;    functions.
  1270                          ;          
  1271                          ;    Currently only the page pointer registers listed below are modified: 
  1272                          ;          CUR_PP
  1273                          ;          IDX_PP
  1274                          ;
  1275                          ;     The receive string is modified by placing Null characters at the end
  1276                          ;     of each parameter as they are recovered.
  1277                          ;
  1278                          ;  THEORY OF OPERATION:
  1279                          ;     This function is a stateful generator of addresses to the "parameters"
  1280                          ;     of an input "Command". It scans the (optional) input buffer and breaks
  1281                          ;     each lexically distinct element into a null-terminated string by replacing
  1282                          ;     delimiters with nulls, as appropriate. The state of the generator is 
  1283                          ;     maintained by the private variable ptrParam, which is a buffer-relative
  1284                          ;     offset. The generator is initialized by a call to the function
  1285                          ;     LTRX_CmdReset which resets the entire buffer to the 'empty'
  1286                          ;     state. Typically this function, LTRX_szGetParam, is
  1287                          ;     not called until the buffer has been loaded with an entire command
  1288                          ;     (See LTRX_bCmdCheck).
  1289                          ;
  1290                          ;     Note, there is no special distinction between the "command" and the 
  1291                          ;     "parameters". The first non-delimiter character of the buffer---the first
  1292                          ;     character of the "command"---is also, for the purposes of this function,
  1293                          ;     the first "parameter" to which it returns an address.
  1294                          ;
  1295                          ;     The value of a delimiter (commonly an ascii space, 0x20 and decimal 32)
  1296                          ;     is determined at configuration time by a user module parameter.
  1297                          ;
  1298  748D                     LTRX_szGetParam:
  1299  748D                    _LTRX_szGetParam:
  1300                             RAM_PROLOGUE RAM_USE_CLASS_4
  1301                             RAM_PROLOGUE RAM_USE_CLASS_3
  1302                              
  1303  748D  62 D0 00             RAM_SETPAGE_CUR >ptrParam
  1304  7490  50 43                mov   A, <LTRX_aRxBuffer                 ; Get address to receive buffer
  1305  7492  02 5F                add   A, [ptrParam]                      ; Add string offset
  1306  7494  5C                   mov   X, A
  1307  7495  62 D3 00             RAM_SETPAGE_IDX >LTRX_aRxBuffer
  1308  7498  52 00                mov   A, [X]                             ; Get character pointed by X
  1309  749A  B004                 jnz   .SkipOverDelimitersLoop            ; Null? No,  continue...
  1310  749C  10                   push  X                                  ;       Yes, Save LSB of current pointer
  1311  749D  8033                 jmp   .End_GetNextParam
  1312                                                                      ; Check for delimiter and keep looping until
  1313                                                                      ; all leading delimiters have been found.
  1314  749F                    .SkipOverDelimitersLoop:
  1315  749F  39 20                cmp   A, LTRX_DELIMITER                  ; Do we have a delimiter?
  1316  74A1  B011                 jnz   .ParamStartFound                   ;   No,  Bingo! found a parameter
  1317  74A3  75                   inc   X                                  ;   Yes, Increment both index and...
  1318  74A4  76 5F                inc   [ptrParam]                         ;          the stored pointer.
  1319  74A6  52 00                mov   A, [X]                             ; Get character pointed by X
  1320  74A8  3C 5F  0F            cmp   [ptrParam], (LTRX_RX_BUFFER_SIZE -1)   ; End of buffer?
  1321  74AB  BFF3                 jnz   .SkipOverDelimitersLoop            ;   No,  continue the scan
  1322                          
  1323  74AD                    .EndOfString:                               ;   Yes, end of string found...
  1324  74AD  10                   push  X                                  ;        Save ptr
  1325  74AE                    .TerminateString:
  1326  74AE  56 00 00             mov   [X], 0x00                          ; Make sure string is zero
  1327  74B1  801F                 jmp   .End_GetNextParam
  1328                          
  1329  74B3                    .ParamStartFound:
  1330  74B3  10                   push  X                                  ; Beginning of parameter found, save pointer
  1331                          
  1332  74B4                    .ParamLoop:                                 ; Now loop until end of parameter found.
  1333  74B4  75                   inc   X                                  ; Advance pointers.
  1334  74B5  76 5F                inc   [ptrParam]
  1335  74B7  3C 5F  0F            cmp   [ptrParam], (LTRX_RX_BUFFER_SIZE -1)   ; Check if we are at the end of buffer
  1336  74BA  AFF3                 jz    .TerminateString
  1337  74BC  52 00                mov   A, [X]                             ; Get next character
  1338  74BE  A012                 jz    .End_GetNextParam
  1339  74C0  39 20                cmp   A, LTRX_DELIMITER                  ; Check if we have a delimiter
  1340  74C2  BFF1                 jnz   .ParamLoop                         ; Still no delimiter, loop again
  1341  74C4  56 00 00             mov   [X], 0x00                          ; Replace delimiter with null for end of substring
  1342  74C7  76 5F                inc   [ptrParam]
  1343  74C9  3C 5F  0F            cmp   [ptrParam], (LTRX_RX_BUFFER_SIZE -1)   ; Check if we are at the end of buffer
  1344  74CC  B004                 jnz   .End_GetNextParam                  ; If not end of string leave
  1345  74CE  55 5F  0F            mov   [ptrParam], (LTRX_RX_BUFFER_SIZE -1)   ; Reset pointer to end of string.
  1346                          
  1347  74D1                    .End_GetNextParam:
  1348  74D1  20                   pop   X
  1349  74D2  10                   push  X
  1350  74D3  3D 00 00             cmp   [X], 0x00
  1351  74D6  B00B                 jnz   .NotNullString
  1352  74D8  20                   pop   X
  1353  74D9  57 00                mov   X, 0x00
  1354  74DB  50 00                mov   A, >LTRX_aRxBuffer
  1355  74DD  70 3F                RAM_EPILOGUE RAM_USE_CLASS_3
  1356                             RAM_EPILOGUE RAM_USE_CLASS_4
  1357  74E1  7F                   ret
  1358                          
  1359  74E2                    .NotNullString:
  1360  74E2  20                   pop  X
  1361  74E3  50 00                mov  A, >LTRX_aRxBuffer                  ; Return pointer
  1362  74E5  70 3F                RAM_EPILOGUE RAM_USE_CLASS_3
  1363                             RAM_EPILOGUE RAM_USE_CLASS_4
  1364  74E9  7F                   ret
  1365                          .ENDSECTION
  1366                          
  1367                          
  1368                          .SECTION
  1369                          ;-----------------------------------------------------------------------------
  1370                          ;  FUNCTION NAME: LTRX_szGetRestOfParams
  1371                          ;
  1372                          ;  DESCRIPTION:
  1373                          ;      Returns a pointer to the rest of the UART RX buffer
  1374                          ;-----------------------------------------------------------------------------
  1375                          ;
  1376                          ;  ARGUMENTS:  none
  1377                          ;
  1378                          ;  RETURNS:
  1379                          ;     A => MSB of parameter
  1380                          ;     X => LSB of parameter
  1381                          ;
  1382                          ;  SIDE EFFECTS:
  1383                          ;    The A and X registers may be modified by this or future implementations
  1384                          ;    of this function.  The same is true for all RAM page pointer registers in
  1385                          ;    the Large Memory Model.  When necessary, it is the calling function's
  1386                          ;    responsibility to perserve their values across calls to fastcall16 
  1387                          ;    functions.
  1388                          ;          
  1389                          ;    Currently only the page pointer registers listed below are modified: 
  1390                          ;          CUR_PP
  1391                          ;
  1392  74EA                     LTRX_szGetRestOfParams:
  1393  74EA                    _LTRX_szGetRestOfParams:
  1394                             RAM_PROLOGUE RAM_USE_CLASS_4
  1395  74EA  62 D0 00             RAM_SETPAGE_CUR >ptrParam
  1396  74ED  50 43                mov  A, <LTRX_aRxBuffer                  ; Get address to receive buffer
  1397  74EF  02 5F                add  A, [ptrParam]                       ; Add string offset
  1398  74F1  5C                   mov  X,A
  1399  74F2  50 00                mov  A,>LTRX_aRxBuffer                   ; Return pointer
  1400                             RAM_EPILOGUE RAM_USE_CLASS_4
  1401  74F4  7F                   ret


HI-TECH Software Macro Assembler (PSoC MCU) V9.61PL1
Symbol Table                                                                                               Fri Feb 06 16:23:18 2009

              LTRX_RX_COMPLETE 0008          LTRX_szGetRestOfParams 74EA                LTRX_RX_INT_MASK 0080  
                 LTRX_RX_ERROR 00E0                        MAC0_CL0 00EE                        MAC0_CL1 00EF  
                      MAC1_CL0 00AE                        MAC1_CL1 00AF                        CLEN_LSB FFFFFFFB  
                      CLEN_MSB FFFFFFFA                LTRX_RX_REG_FULL 0008                   LTRX_CmdReset 745E  
                         MAC_X 00EC                           MAC_Y 00ED               LTRX_RX_BUF_ERROR 00F0  
                    LTRX_Start 732E                      LTRX_Write 73EF                 LTRX_szGetParam 748D  
               LTRX_PutSHexInt 739B                        CSTR_LSB FFFFFFFD                        CSTR_MSB FFFFFFFC  
       bfCONTROL_REG_START_BIT 0001         _LTRX_szGetRestOfParams 74EA              LTRX_RX_BUFFER_REG 003E  
              LTRX_TX_FUNC_REG 0038           LTRX_RX_FRAMING_ERROR 0020                          ??0000 73A2  
                        ??0001 7401                          ??0002 7428                     _LTRX_Start 732E  
                   _LTRX_Write 73EF                   End_PutString 73EA                   LTRX_SendData 733E  
              LTRX_TX_INT_MASK 0040                   LTRX_cGetChar 73AA                _LTRX_DisableInt 7315  
                   LTRX_CWrite 7415                          MAC0_X 00EC                          MAC0_Y 00ED  
                        MAC1_X 00AC                          MAC1_Y 00AD                          HITECH 0002  
               FLAG_PGMODE_01b 0040                 FLAG_PGMODE_10b 0080                          IDX_PP 00D3  
                        CUR_PP 00D0                     LTRX_bRxCnt 0041                  LTRX_EnableInt 730E  
              LTRX_bReadRxData 7344                 LTRX_CPutString 7443                LTRX_PutSHexByte 7388  
            End_LTRX_cReadChar 73C8             LTRX_RX_BUFFER_SIZE 0010                    _LTRX_CWrite 7415  
             LTRX_SetTxIntMode 731C               LTRX_RXBUF_ENABLE 0001               _LTRX_bReadRxData 7344  
                LTRX_bCmdCheck 7474               _LTRX_PutSHexByte 7388                    LTRX_HEX_STR 7378  
     SYSTEM_LARGE_MEMORY_MODEL 0001              End_LTRX_iReadChar 73DE              LTRX_bReadRxStatus 7347  
        SYSTEM_MULTIPAGE_STACK 0000                _LTRX_bCmdLength 7487                  LTRX_bErrCheck 747C  
            LTRX_bReadTxStatus 7341                 LTRX_RX_INT_REG 00E1             LTRX_RX_CONTROL_REG 003F  
            bLTRX_ReadRxStatus 7347                       LTRX_Stop 7337                 LTRX_RX_NO_DATA 0001  
                       MAC_CL0 00EE                         MAC_CL1 00EF             LTRX_RX_BUF_CMDTERM 0001  
                       CNT_LEN FFFFFFFB              bLTRX_ReadTxStatus 7341                  LTRX_cReadChar 73B2  
                LTRX_TxIntMode 734A             LTRX_TX_CONTROL_REG 003B                    LTRX_IntCntl 735D  
                LTRX_aRxBuffer 0043                FLAG_PGMODE_MASK 00C0                      _LTRX_Stop 7337  
               _LTRX_EnableInt 730E                 LTRX_TX_INT_REG 00E1                bLTRX_ReadRxData 7344  
               RAM_USE_CLASS_1 0001                 RAM_USE_CLASS_2 0002                 RAM_USE_CLASS_3 0004  
               RAM_USE_CLASS_4 0008                    LTRX_PutCRLF 7455              _LTRX_SetTxIntMode 731C  
                  LTRX_PutChar 73A2                  LTRX_PutString 73DF              LTRX_ENABLE_RX_INT 0001  
                       STR_LSB FFFFFFFD                         STR_MSB FFFFFFFC              LTRX_ENABLE_TX_INT 0002  
                  LTRX_fStatus 0040  bfFUNCTION_REG_TX_INT_MODE_BIT 0010                  LTRX_iReadChar 73C9  
               LTRX_DisableInt 7315                _LTRX_szGetParam 748D              LTRX_TX_BUFFER_REG 0039  
             _bLTRX_ReadRxData 7344                _LTRX_PutSHexInt 739B                 _LTRX_bCmdCheck 7474  
                      ptrParam 005F                  _LTRX_CmdReset 745E                  LTRX_DELIMITER 0020  
               _LTRX_bErrCheck 747C                 _LTRX_cReadChar 73B2                 _LTRX_TxIntMode 734A  
                _LTRX_SendData 733E       LTRX_INT_MODE_TX_COMPLETE 0001                  _LTRX_cGetChar 73AA  
             SYSTEM_STACK_PAGE 0007            LTRX_TX_BUFFER_EMPTY 0010             _LTRX_bReadRxStatus 7347  
              _LTRX_CPutString 7443                   FLAG_XIO_MASK 0010                 _LTRX_PutString 73DF  
                 _LTRX_IntCntl 735D             _LTRX_bReadTxStatus 7341      SYSTEM_IDXPG_TRACKS_IDX_PP 0001  
          LTRX_RX_PARITY_ERROR 0080                   _LTRX_PutCRLF 7455      SYSTEM_IDXPG_TRACKS_STK_PP 0000  
           _bLTRX_ReadRxStatus 7347                   _LTRX_PutChar 73A2                 _LTRX_iReadChar 73C9  
           _bLTRX_ReadTxStatus 7341                 LTRX_bCmdLength 7487  
