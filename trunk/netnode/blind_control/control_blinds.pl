#! /usr/bin/perl -w

# Control blinds script
#
# This script is the main control script for the sunblinds.
# It does the following: 
#  * firstly it tries to read the ambient light level from
#    the wireless sensor gateway (that received light level values from the sensor
#    in the garden)
#  * if the gateway is not responding or the sensor in not transmitting 
#    values in the last measurement interval, the script reverts to 
#    'calculated' sunrise/sunset times that are read from an XML file.
#    That file is generated by the 'write_blind_control_setting.pl' script
# 
# Every time the script is run, it compared the 'wanted' state with the last
# commanded state (read from the status file called 'last_command.txt').
#
# It is the idea to call this script once every minute. It is however safe to run the script
# less frequently. This is covered by comparing the most recent command with the command
# stored in the status file. If both commands don't match, an update is sent to the
# blind controller. This also covers cases when e.g. the network or the server went down:
# if sending a command to the blind controller fails, the status file is not updated so 
# that the command will be resent the next time the script is run.
#
# L. Hollevoet, 2007.
use strict;

use XML::Simple;
use IO::Socket;
use Net::hostent; 

# Register ALARM signal
$SIG{ALRM} = sub { die "timeout" };

my $gateway_host = 'oswald-03';
my $next_command;

# First try to get and parse the ambient light level from the garden sensor
if (sensor_value_valid()){
    $next_command = parse_sensor_report();
} else {
    $next_command = determine_calculated_command();
}

# Check if we need to apply the next command.

# Do so if required

my $socket;

if (open_socket()) { # Open the socket with possibility to retry if the target port is in use (can happen on the Lantronix XPORT)
    $socket->send("?\r");

    my $response = &read_serial(10);

    if (se)
} else {
    # Go for the precalculated values
}
# Command file
my $state_file = 'last_command.txt';

# Get the last command we sent to the blind controller
my $last_command = &get_last_command($state_file);

#print "Last command was: $last_command\n";

my $xml = new XML::Simple(keyattr => ['time']);

my $config = $xml->XMLin("blind_settings_today.xml");

# Get the local time
my ($sec, $min, $hour) = localtime(time);

# Make sure to append a '0' if required, this is done so that the
# time can easily be compared to the times stored in the command file
my $minutes = $min > 9 ? "$min" : "0$min"; 
my $hours = $hour > 9 ? "$hour" : "0$hour";

my $current_time = $hours . ':' . $minutes;

# Determine the command that is valid now
my $lastmatch;

foreach (sort keys %{$config->{command}}){
	my $compare_time = $_;
	# Determine the last command
	if ($current_time ge $compare_time){
		$lastmatch = $compare_time;		
	}
}
 
# Get the actual command of the last programmed command (up or down)
my $lastmatch_command = $config->{command}->{$lastmatch}->{direction};
#print "Last match was $lastmatch, direction $lastmatch_command\n";

# If the command and the status file don't match, update!
if ($last_command ne $lastmatch_command){
	print "[$current_time] Last known sent command does not match the last command in the settings file. Updating!\n";
	
	# Send it to the blind controller
	if (&command_blinds($lastmatch_command)){
		&save_last_command($state_file, $lastmatch_command);
	}
} else {
	print "[$current_time] No action taken, blinds already in position\n";
}

exit(0);

############################################################################
# Subroutines
################

#
# Blind controller related
#
sub command_blinds () {
	my $blind_command = shift();
	
	my $host = $config->{target}->{host};
	my $port = $config->{target}->{port};
	
	#print "SENDING COMMAND TO [$host:$port] : $blind_command\n";
	
	my $handle = IO::Socket::INET->new(Proto => "tcp", PeerAddr => $config->{target}->{host}, PeerPort => $config->{target}->{port}, Type => SOCK_STREAM);
	if (!defined($handle)){
		print "[$current_time] Could not connect to '$host'! The command will be resent when the script runs the next time.\n";
		return 0;
	}
	print $handle $blind_command;

	sleep(50);

	print $handle $blind_command;

	$handle->close();
					
	return 1;
}

#
# Program helper functions
#

## Retrieve the last command sent to the blind controller from this script
sub get_last_command(){
	
	# Get filename
	my $filename = shift();
	
	# Default assignment of the last command
	my $last_command = '?';
	if (open (STATUS, $filename) ){
		$last_command = <STATUS>;
		chomp($last_command);
	} else {
		print "Could not open last command file, creating new one...\n";
	};
	
	close(STATUS);
	
	return $last_command;
}

## Save the last command sent to the blind controller from this script
sub save_last_command(){
	
	# Get filename and last command
	my $filename = shift();
	my $last_command = shift();
	
	open (STATUS, ">", $filename) or (die "Could not open state file for output: $!");
	
	print STATUS "$last_command";
	
	close (STATUS);
	
	return;
}	


######## Wireless gateway related routines
###############################################################
## parse_and_post(response)
# Parse the returned string and post the results to the RRD 
# database
###############################################################
sub parse_and_post() {
	my $data = shift();
	
	my ($hex1, $hex2, $hex3);
	
	# Extract values
	if ($data =~ /Node 1: ([0-9A-F]{2}) ([0-9A-F]{2}) ([0-9A-F]{2})/) { $hex1 = $1; $hex2 = $2; $hex3 = $3;}
	
	# Convert to decimal
	my $solar_adc = hex($hex1);
	my $vcc_adc   = hex($hex2);
	my $temp_adc  = hex($hex3);
	
	# Convert to human readable
	my $solar_voltage = $solar_adc * 2.5 / 255 * 2;
	my $vcc_voltage   = 2.5 * 255 / $vcc_adc;
	my $temperature   = (($temp_adc * 2.5 / 255) - 0.600) / 0.01; # LM61 temperature sensor
	
	# Sanity check
	if ($solar_voltage > 5) {$solar_voltage = 5};
	if ($vcc_voltage   > 5) {$vcc_voltage   = 5};
	
	print "Read from node 1: solar $solar_adc ($solar_voltage)\t vcc $vcc_adc ($vcc_voltage)\t temp: $temperature\n";
	
	RRDs::update("$rrd_name.rrd","N:$solar_voltage:$vcc_voltage:$temperature");
	my $err = RRDs::error;
	die "Error while updating $rrd_name.rrd: $err\n" if $err;
}

###############################################################
## read_serial(timeout)
#   Reads data from the serial port. Times out if nothing is
#   received after <timeout> seconds.
###############################################################
sub read_serial() {
    my $timeout = shift();

    my @numresult;
    my $result;

    eval {
	# Set alarm
	alarm($timeout);

	# Execute receive code
	my $waiting = 1;
	$result = "";
	my $res = "";
	while ($waiting){

	    # Read reply
	    ($socket->recv($res, 32));
	    # Verify we have the entire string (should end with 0x04 and no preceding 0x05)
	    $result .= $res;
	    if (($result =~ /EOT/)) {
		$waiting = 0;
	    }
	}
	
	# Clear alarm
	alarm(0);
    };

    # Check what happened in the eval loop
    if ($@) {
	if ($@ =~ /timeout/) {
	    # Oops, we had a timeout
	    print "Received up to now: $result";

	    &handle_timeout;
	    
	} else {
	    # Oops, we died
	    alarm(0);           # clear the still-pending alarm
	    die;                # propagate unexpected exception
	} 
	
    } 

    # We get here if the eval exited normally
    #@numresult = &parse_response($result);
	return $result;
	
}


###############################################################
## handle_timeout
#   Close everything and exit if we have a timeout
###############################################################
sub handle_timeout() {
    &close_port();
    &error("Timeout while waiting for data from PIC! Check your cables and connections.\n");
}

###############################################################
## Print fancy header at program startup
###############################################################
sub print_header() {

    # Calculate file age
    #my @info = stat($r_config->{filename});
    #my @nowtime = Time_to_Date(time());
    #my @filetime =Time_to_Date($info[9]); 
    #my @diff = Delta_DHMS(@filetime, @nowtime);
   
    print "--------------------------------------\n";
    print "Net Temp listener v$version\n";
    print "L. Hollevoet 2006\n";
    print "--------------------------------------\n";
    #print "\nOn port: $r_config->{comport}, $r_config->{baudrate}\n\n";


}

###############################################################
## debug
#   Debug print supporting multiple log levels
###############################################################
sub debug {

    my $debuglevel = shift();
    my $logline = shift();
	
    if ($debuglevel <= $global->{verbose}) {
	print(STDOUT "+$debuglevel= $logline\n");
    } # end print to log or STDERR

} 

###############################################################
## dec2hex
#   Convert dec number into hex string
###############################################################
sub dec2hex() {
    my $dec  = shift();
    my $fill = shift();

    my $fmt_string;

    if (defined($fill)){
	$fmt_string = "%0" . $fill . "X";
    } else {
	$fmt_string = "%02X";
    }
    return sprintf($fmt_string, $dec );
}

## Generate 3 address bytes from integer number
sub gen_address(){
    my $address = shift();

    my $string = &dec2hex($address, 6);

    # Address format required by bootloader: <ADDRL:ADDRH:ADDRU>
    my $addr = substr($string, 4, 2) . substr($string, 2, 2) . substr($string, 0, 2);
    
    return $addr; 
}
###############################################################
## min(val1, val2)
#   Return the minimum of 2 values
###############################################################
sub min(){
    my $a = shift();
    my $b = shift();

    return  ($a<$b) ? $a : $b;
}

###############################################################
## clean_and_exit
#   Shutdown cleanly
###############################################################
sub clean_and_exit() {
    &close_port();    
    exit 0;
}

###############################################################
## error
#   Signal error and exit
###############################################################
sub error() {
    my $data = shift();
    print $data;
    &close_port();
    exit 1;
}

###############################################################
## close_port
#   Close the serial port
###############################################################
sub close_port(){
    if (defined $socket){
	$socket->close();
    }    
}

sub open_socket(){
    # Connect to the remote device 
    # create a tcp connection to the specified host and port
    my ($client_host, $client_port, $kidpid, $handle, $line);

    $client_host = $gateway_host; 
    $client_port = 10001;

    my $timeout = 0;

    while () {
        if ($socket = IO::Socket::INET->new(Proto     => "tcp",
					PeerAddr  => $client_host,
					PeerPort  => $client_port,
					Type      => SOCK_STREAM)){
	   last;
        } else {
	   print "Waiting for server to become available...\n";
	   $timeout++;
	   if ($timeout == 10){
	     die "Server not available for 10 seconds...\n";
	   }
	   sleep 1;
        }
    }
}
